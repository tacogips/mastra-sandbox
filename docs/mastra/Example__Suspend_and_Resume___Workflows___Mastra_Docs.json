{
    "id": "https://mastra.ai/examples/workflows/suspend-and-resume",
    "title": "Example: Suspend and Resume | Workflows | Mastra Docs",
    "url": "https://mastra.ai/examples/workflows/suspend-and-resume",
    "publishedDate": "",
    "author": "",
    "text": "Workflow with Suspend and Resume \n Workflow steps can be suspended and resumed at any point in the workflow execution. This example demonstrates how to suspend a workflow step and resume it later. \n Basic Example \n import { Mastra } from ' @mastra/core '; \n import { Step, Workflow } from ' @mastra/core/workflows '; \n import { z } from ' zod '; \n \n const stepOne = new Step ({ \n id: ' stepOne ', \n outputSchema: z. object ({ \n doubledValue: z. number (), \n }), \n execute: async ({ context }) =&gt; { \n const doubledValue = context.triggerData.inputValue * 2; \n return { doubledValue }; \n }, \n}); \n const stepTwo = new Step ({ \n id: ' stepTwo ', \n outputSchema: z. object ({ \n incrementedValue: z. number (), \n }), \n execute: async ({ context, suspend }) =&gt; { \n \n const secondValue = context.inputData?.secondValue?? 0; \n const doubledValue = context. getStepResult (stepOne)?.doubledValue?? 0; \n \n const incrementedValue = doubledValue + secondValue; \n \n if (incrementedValue &lt; 100) { \n await suspend (); \n return { incrementedValue: 0 }; \n } \n return { incrementedValue }; \n }, \n}); \n \n // Build the workflow \n const myWorkflow = new Workflow ({ \n name: ' my-workflow ', \n triggerSchema: z. object ({ \n inputValue: z. number (), \n }), \n}); \n \n // run workflows in parallel \n myWorkflow \n . step (stepOne) \n . then (stepTwo) \n . commit (); \n // Register the workflow \n export const mastra = new Mastra ({ \n workflows: { registeredWorkflow: myWorkflow }, \n}) \n \n // Get registered workflow from Mastra \n const registeredWorkflow = mastra. getWorkflow ( ' registeredWorkflow '); \n const { runId, start } = registeredWorkflow. createRun (); \n \n // Start watching the workflow before executing it \n myWorkflow. watch ( async ({ context, activePaths }) =&gt; { \n for ( const _path of activePaths) { \n const stepTwoStatus = context.steps?.stepTwo?.status; \n if (stepTwoStatus === ' suspended ') { \n console. log ( \" Workflow suspended, resuming with new value \"); \n \n // Resume the workflow with new context \n await myWorkflow. resume ({ \n runId, \n stepId: ' stepTwo ', \n context: { secondValue: 100 }, \n }); \n } \n } \n}) \n \n // Start the workflow execution \n await start ({ triggerData: { inputValue: 45 } }); \n Advanced Example with Multiple Suspension Points Using async/await pattern and suspend payloads \n This example demonstrates a more complex workflow with multiple suspension points using the async/await pattern. It simulates a content generation workflow that requires human intervention at different stages. \n import { Mastra } from ' @mastra/core '; \n import { Step, Workflow } from ' @mastra/core/workflows '; \n import { z } from ' zod '; \n \n // Step 1: Get user input \n const getUserInput = new Step ({ \n id: ' getUserInput ', \n execute: async ({ context }) =&gt; { \n // In a real application, this might come from a form or API \n return { userInput: context.triggerData.input }; \n }, \n outputSchema: z. object ({ userInput: z. string () }), \n}); \n // Step 2: Generate content with AI (may suspend for human guidance) \n const promptAgent = new Step ({ \n id: ' promptAgent ', \n inputSchema: z. object ({ \n guidance: z. string (), \n }), \n execute: async ({ context, suspend }) =&gt; { \n const userInput = context. getStepResult (getUserInput)?.userInput; \n console. log ( ` Generating content based on: ${ userInput}`); \n \n const guidance = context.inputData?.guidance; \n \n // Simulate AI generating content \n const initialDraft = generateInitialDraft (userInput); \n \n // If confidence is high, return the generated content directly \n if (initialDraft.confidenceScore &gt; 0.7) { \n return { modelOutput: initialDraft.content }; \n } \n \n console. log ( ' Low confidence in generated content, suspending for human guidance ', {guidance}); \n \n // If confidence is low, suspend for human guidance \n if (! guidance) { \n // only suspend if no guidance is provided \n await suspend (); \n return undefined; \n } \n \n // This code runs after resume with human guidance \n console. log ( ' Resumed with human guidance '); \n \n // Use the human guidance to improve the output \n return { \n modelOutput: enhanceWithGuidance (initialDraft.content, guidance), \n }; \n }, \n outputSchema: z. object ({ modelOutput: z. string () }). optional (), \n}); \n // Step 3: Evaluate the content quality \n const evaluateTone = new Step ({ \n id: ' evaluateToneConsistency ', \n execute: async ({ context }) =&gt; { \n const content = context. getStepResult (promptAgent)?.modelOutput; \n \n // Simulate evaluation \n return { \n toneScore: { score: calculateToneScore (content) }, \n completenessScore: { score: calculateCompletenessScore (content) }, \n }; \n }, \n outputSchema: z. object ({ \n toneScore: z. any (), \n completenessScore: z. any (), \n }), \n}); \n // Step 4: Improve response if needed (may suspend) \n const improveResponse = new Step ({ \n id: ' improveResponse ', \n inputSchema: z. object ({ \n improvedContent: z. string (), \n resumeAttempts: z. number (), \n }), \n execute: async ({ context, suspend }) =&gt; { \n const content = context. getStepResult (promptAgent)?.modelOutput; \n const toneScore = \n context. getStepResult (evaluateTone)?.toneScore.score?? 0; \n const completenessScore = \n context. getStepResult (evaluateTone)?.completenessScore.score?? 0; \n \n const improvedContent = context.inputData.improvedContent; \n const resumeAttempts = context.inputData.resumeAttempts?? 0; \n \n // If scores are above threshold, make minor improvements \n if (toneScore &gt; 0.8 &amp;&amp; completenessScore &gt; 0.8) { \n return { improvedOutput: makeMinorImprovements (content) }; \n } \n \n console. log ( ' Content quality below threshold, suspending for human intervention ', {improvedContent, resumeAttempts}); \n \n if (! improvedContent) { \n // Suspend with payload containing content and resume attempts \n await suspend ({ \n content, \n scores: { tone: toneScore, completeness: completenessScore }, \n needsImprovement: toneScore &lt; 0.8 ? ' tone ' : ' completeness ', \n resumeAttempts: resumeAttempts + 1, \n }); \n return { improvedOutput: content?? '' }; \n } \n \n console. log ( ' Resumed with human improvements ', improvedContent); \n return { improvedOutput: improvedContent?? content?? '' }; \n }, \n outputSchema: z. object ({ improvedOutput: z. string () }). optional (), \n}); \n // Step 5: Final evaluation \n const evaluateImproved = new Step ({ \n id: ' evaluateImprovedResponse ', \n execute: async ({ context }) =&gt; { \n const improvedContent = context. getStepResult (improveResponse)?.improvedOutput; \n \n // Simulate final evaluation \n return { \n toneScore: { score: calculateToneScore (improvedContent) }, \n completenessScore: { score: calculateCompletenessScore (improvedContent) }, \n }; \n }, \n outputSchema: z. object ({ \n toneScore: z. any (), \n completenessScore: z. any (), \n }), \n}); \n \n // Build the workflow \n const contentWorkflow = new Workflow ({ \n name: ' content-generation-workflow ', \n triggerSchema: z. object ({ input: z. string () }), \n}); \n \n contentWorkflow \n . step (getUserInput) \n . then (promptAgent) \n . then (evaluateTone) \n . then (improveResponse) \n . then (evaluateImproved) \n . commit (); \n // Register the workflow \n const mastra = new Mastra ({ \n workflows: { contentWorkflow }, \n}); \n \n // Helper functions (simulated) \n function generateInitialDraft (input: string = '') { \n // Simulate AI generating content \n return { \n content: ` Generated content based on: ${ input}`, \n confidenceScore: 0.6, // Simulate low confidence to trigger suspension \n }; \n} \n \n function enhanceWithGuidance (content: string = '', guidance: string = '') { \n return `${ content} (Enhanced with guidance: ${ guidance}) `; \n} \n \n function makeMinorImprovements (content: string = '') { \n return `${ content} (with minor improvements) `; \n} \n \n function calculateToneScore (_: string = '') { \n return 0.7; // Simulate a score that will trigger suspension \n} \n \n function calculateCompletenessScore (_: string = '') { \n return 0.9; \n} \n \n // Usage example \n async function runWorkflow () { \n const workflow = mastra. getWorkflow ( ' contentWorkflow '); \n const { runId, start } = workflow. createRun (); \n \n let finalResult: any; \n \n // Start the workflow \n const initialResult = await start ({ \n triggerData: { input: ' Create content about sustainable energy ' }, \n }); \n \n console. log ( ' Initial workflow state: ', initialResult.results); \n \n const promptAgentStepResult = initialResult.activePaths. get ( ' promptAgent '); \n \n // Check if promptAgent step is suspended \n if (promptAgentStepResult?.status === ' suspended ') { \n console. log ( ' Workflow suspended at promptAgent step '); \n console. log ( ' Suspension payload: ', promptAgentStepResult?.suspendPayload); \n \n // Resume with human guidance \n const resumeResult1 = await workflow. resume ({ \n runId, \n stepId: ' promptAgent ', \n context: { \n guidance: ' Focus more on solar and wind energy technologies ', \n }, \n }); \n \n console. log ( ' Workflow resumed and continued to next steps '); \n \n let improveResponseResumeAttempts = 0; \n let improveResponseStatus = resumeResult1?.activePaths. get ( ' improveResponse ')?.status; \n \n // Check if improveResponse step is suspended \n while (improveResponseStatus === ' suspended ') { \n console. log ( ' Workflow suspended at improveResponse step '); \n console. log ( ' Suspension payload: ', resumeResult1?.activePaths. get ( ' improveResponse ')?.suspendPayload); \n \n const improvedContent = \n improveResponseResumeAttempts &lt; 3 \n ? undefined \n : ' Completely revised content about sustainable energy focusing on solar and wind technologies '; \n \n // Resume with human improvements \n finalResult = await workflow. resume ({ \n runId, \n stepId: ' improveResponse ', \n context: { \n improvedContent, \n resumeAttempts: improveResponseResumeAttempts, \n }, \n }); \n \n improveResponseResumeAttempts = \n finalResult?.activePaths. get ( ' improveResponse ')?.suspendPayload?.resumeAttempts ?? 0; \n improveResponseStatus = finalResult?.activePaths. get ( ' improveResponse ')?.status; \n \n console. log ( ' Improved response result: ', finalResult?.results); \n } \n } \n return finalResult; \n} \n \n // Run the workflow \n const result = await runWorkflow (); \n console. log ( ' Workflow completed '); \n console. log ( ' Final workflow result: ', result); \n \n",
    "image": "https://mastra.ai/api/og/docs?title=Example:%20Suspend%20and%20Resume%20|%20Workflows%20|%20Mastra%20Docs&description=Example%20of%20using%20Mastra%20to%20suspend%20and%20resume%20workflow%20steps%20during%20execution.",
    "favicon": "https://mastra.ai/favicon.ico",
    "extras": {
        "links": [
            "https://mastra.ai/en/examples/workflows/suspend-and-resume",
            "https://mastra.ai/",
            "https://mastra.ai/docs",
            "https://mastra.ai/examples"
        ]
    }
}