{
    "id": "https://mastra.ai/docs/workflows-vnext/flow-control",
    "title": "Branching, Merging, Conditions | Workflows (vNext) | Mastra Docs",
    "url": "https://mastra.ai/docs/workflows-vnext/flow-control",
    "author": "",
    "text": "Sequential Flow \n Chain steps to execute in sequence using.then(): \n myWorkflow. then (step1). then (step2). then (step3). commit (); \n The output from each step is automatically passed to the next step if schemas match. If the schemas donâ€™t match, you can use the map function to transform the output to the expected schema.\nStep chaining is type-safe and checked at compile time. \n Parallel Execution \n Execute steps in parallel using.parallel(): \n myWorkflow. parallel ([step1, step2]). then (step3). commit (); \n This executes all steps in the array concurrently, then continues to the next step after all parallel steps complete. \n You can also execute entire workflows in parallel: \n myWorkflow \n . parallel ([nestedWorkflow1, nestedWorkflow2]) \n . then (finalStep) \n . commit (); \n Parallel steps receive previous step results as input. Their outputs are passed into the next step input as an object where the key is the step id and the value is the step output, for example the above example outputs an object with two keys nestedWorkflow1 and nestedWorkflow2 with the outputs of the respective workflows as values. \n Conditional Branching \n Create conditional branches using.branch(): \n myWorkflow \n . then (initialStep) \n . branch ([ \n [ async ({ inputData }) =&gt; inputData.value &gt; 50, highValueStep], \n [ async ({ inputData }) =&gt; inputData.value &gt; 10 &amp;&amp; inputData.value &lt;= 50, lowValueStep], \n [ async ({ inputData }) =&gt; inputData.value &lt;= 10, extremelyLowValueStep], \n ]) \n . then (finalStep) \n . commit (); \n Branch conditions are evaluated sequentially, and all steps with matching conditions are executed in parallel. If inputData.value is 5 then both lowValueStep and extremelyLowValueStep will be run. \n Each conditional step (like highValueStep or lowValueStep) receives as input the output of the previous step ( initialStep in this case). The output of each matching conditional step is collected. The next step after the branch ( finalStep) receives an object containing the outputs of all the steps that were run in the branch. The keys of this object are the step IDs, and the values are the outputs of those steps ( { lowValueStep: &lt;output of lowValueStep&gt;, extremelyLowValueStep: &lt;output of extremelyLowValueStep&gt; }). \n Loops \n vNext supports two types of loops. When looping a step (or nested workflow or any other step-compatible construct), the inputData of the loop is the output of the previous step initially, but any subsequent inputData is the output of the loop step itself. Thus for looping, the initial loop state should either match the previous step output or be derived using the map function. \n Do-While Loop: Executes a step repeatedly while a condition is true. \n myWorkflow \n . dowhile (incrementStep, async ({ inputData }) =&gt; inputData.value &lt; 10) \n . then (finalStep) \n . commit (); \n Do-Until Loop: Executes a step repeatedly until a condition becomes true. \n myWorkflow \n . dountil (incrementStep, async ({ inputData }) =&gt; inputData.value &gt;= 10) \n . then (finalStep) \n . commit (); \n const workflow = createWorkflow ({ \n id: \" increment-workflow \", \n inputSchema: z. object ({ \n value: z. number (), \n }), \n outputSchema: z. object ({ \n value: z. number (), \n }), \n}) \n . dountil (incrementStep, async ({ inputData }) =&gt; inputData.value &gt;= 10) \n . then (finalStep); \n Foreach \n Foreach is a step that executes a step for each item in an array type input. \n const mapStep = createStep ({ \n id: \" map \", \n description: \" Maps (+11) on the current value \", \n inputSchema: z. object ({ \n value: z. number (), \n }), \n outputSchema: z. object ({ \n value: z. number (), \n }), \n execute: async ({ inputData }) =&gt; { \n return { value: inputData.value + 11 }; \n }, \n}); \n \n const finalStep = createStep ({ \n id: \" final \", \n description: \" Final step that prints the result \", \n inputSchema: z. array (z. object ({ value: z. number () })), \n outputSchema: z. object ({ \n finalValue: z. number (), \n }), \n execute: async ({ inputData }) =&gt; { \n return { finalValue: inputData. reduce ((acc, curr) =&gt; acc + curr.value, 0) }; \n }, \n}); \n \n const counterWorkflow = createWorkflow ({ \n steps: [mapStep, finalStep], \n id: \" counter-workflow \", \n inputSchema: z. array (z. object ({ value: z. number () })), \n outputSchema: z. object ({ \n finalValue: z. number (), \n }), \n}); \n \n counterWorkflow. foreach (mapStep). then (finalStep). commit (); \n \n const run = counterWorkflow. createRun (); \n const result = await run. start ({ \n inputData: [{ value: 1 }, { value: 22 }, { value: 333 }], \n}); \n \n if (result.status === \" success \") { \n console. log (result.result); // only exists if status is success \n} else if (result.status === \" failed \") { \n console. error (result.error); // only exists if status is failed, this is an instance of Error \n} \n The loop executes the step for each item in the input array in sequence one at a time. The optional concurrency option allows you to execute steps in parallel with a limit on the number of concurrent executions. \n counterWorkflow. foreach (mapStep, { concurrency: 2 }). then (finalStep). commit (); \n Nested Workflows \n vNext supports composing workflows by nesting them: \n const nestedWorkflow = createWorkflow ({ \n id: ' nested-workflow ', \n inputSchema: z. object ({...}), \n outputSchema: z. object ({...}), \n}) \n . then (step1) \n . then (step2) \n . commit (); \n \n const mainWorkflow = createWorkflow ({ \n id: ' main-workflow ', \n inputSchema: z. object ({...}), \n outputSchema: z. object ({...}), \n}) \n . then (initialStep) \n . then (nestedWorkflow) \n . then (finalStep) \n . commit (); \n In the above example, the nestedWorkflow is used as a step in the mainWorkflow, where the inputSchema of nestedWorkflow matches the outputSchema of initialStep, and the outputSchema of nestedWorkflow matches the inputSchema of finalStep. \n Nested workflows are the main (and only) way compose execution flows beyond simple sequential execution. When using.branch() or.parallel() to compose execution flows, executing more than just one step necessarily requires a nested workflow, and as a byproduct, a description of how these steps are to be executed. \n const planBothWorkflow = createWorkflow ({ \n id: \" plan-both-workflow \", \n inputSchema: forecastSchema, \n outputSchema: z. object ({ \n activities: z. string (), \n }), \n steps: [planActivities, planIndoorActivities, sythesizeStep], \n}) \n . parallel ([planActivities, planIndoorActivities]) \n . then (sythesizeStep) \n . commit (); \n \n const weatherWorkflow = createWorkflow ({ \n id: \" weather-workflow-step3-concurrency \", \n inputSchema: z. object ({ \n city: z. string (). describe ( \" The city to get the weather for \"), \n }), \n outputSchema: z. object ({ \n activities: z. string (), \n }), \n steps: [fetchWeather, planBothWorkflow, planActivities], \n}) \n . then (fetchWeather) \n . branch ([ \n [ \n async ({ inputData }) =&gt; { \n return inputData?.precipitationChance &gt; 20; \n }, \n planBothWorkflow, \n ], \n [ \n async ({ inputData }) =&gt; { \n return inputData?.precipitationChance &lt;= 20; \n }, \n planActivities, \n ], \n ]); \n Nested workflows only have their final result (result of the last step) as their step output.",
    "image": "https://mastra.ai/api/og/docs?title=Branching,%20Merging,%20Conditions%20|%20Workflows%20(vNext)%20|%20Mastra%20Docs&description=Control%20flow%20in%20Mastra%20(vNext)%20workflows%20allows%20you%20to%20manage%20branching,%20merging,%20and%20conditions%20to%20construct%20workflows%20that%20meet%20your%20logic%20requirements.",
    "favicon": "https://mastra.ai/favicon.ico",
    "extras": {
        "links": [
            "https://mastra.ai/en/docs/workflows-vnext/flow-control",
            "https://mastra.ai/",
            "https://mastra.ai/docs",
            "https://mastra.ai/examples"
        ]
    }
}