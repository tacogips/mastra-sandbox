{
    "id": "https://mastra.ai/docs/workflows/dynamic-workflows",
    "title": "Dynamic Workflows | Mastra Docs",
    "url": "https://mastra.ai/docs/workflows/dynamic-workflows",
    "author": "",
    "text": "\n This guide demonstrates how to create dynamic workflows within a workflow step. This advanced pattern allows you to create and execute workflows on the fly based on runtime conditions. \n Overview \n Dynamic workflows are useful when you need to create workflows based on runtime data. \n Implementation \n The key to creating dynamic workflows is accessing the Mastra instance from within a stepâ€™s execute function and using it to create and run a new workflow. \n Basic Example \n import { Mastra, Step, Workflow } from ' @mastra/core '; \n import { z } from ' zod '; \n \n const isMastra = (mastra: any): mastra is Mastra =&gt; { \n return mastra &amp;&amp; typeof mastra === ' object ' &amp;&amp; mastra instanceof Mastra; \n}; \n \n // Step that creates and runs a dynamic workflow \n const createDynamicWorkflow = new Step ({ \n id: ' createDynamicWorkflow ', \n outputSchema: z. object ({ \n dynamicWorkflowResult: z. any (), \n }), \n execute: async ({ context, mastra }) =&gt; { \n if (! mastra) { \n throw new Error ( ' Mastra instance not available '); \n } \n \n if (! isMastra (mastra)) { \n throw new Error ( ' Invalid Mastra instance '); \n } \n \n const inputData = context.triggerData.inputData; \n \n // Create a new dynamic workflow \n const dynamicWorkflow = new Workflow ({ \n name: ' dynamic-workflow ', \n mastra, // Pass the mastra instance to the new workflow \n triggerSchema: z. object ({ \n dynamicInput: z. string (), \n }), \n }); \n \n // Define steps for the dynamic workflow \n const dynamicStep = new Step ({ \n id: ' dynamicStep ', \n execute: async ({ context }) =&gt; { \n const dynamicInput = context.triggerData.dynamicInput; \n return { \n processedValue: ` Processed: ${ dynamicInput}`, \n }; \n }, \n }); \n \n // Build and commit the dynamic workflow \n dynamicWorkflow. step (dynamicStep). commit (); \n \n // Create a run and execute the dynamic workflow \n const run = dynamicWorkflow. createRun (); \n const result = await run. start ({ \n triggerData: { \n dynamicInput: inputData, \n }, \n }); \n \n let dynamicWorkflowResult; \n \n if (result.results[ ' dynamicStep ']?.status === ' success ') { \n dynamicWorkflowResult = result.results[ ' dynamicStep ']?.output.processedValue; \n } else { \n throw new Error ( ' Dynamic workflow failed '); \n } \n \n // Return the result from the dynamic workflow \n return { \n dynamicWorkflowResult, \n }; \n }, \n}); \n \n // Main workflow that uses the dynamic workflow creator \n const mainWorkflow = new Workflow ({ \n name: ' main-workflow ', \n triggerSchema: z. object ({ \n inputData: z. string (), \n }), \n mastra: new Mastra (), \n}); \n \n mainWorkflow. step (createDynamicWorkflow). commit (); \n \n // Register the workflow with Mastra \n export const mastra = new Mastra ({ \n workflows: { mainWorkflow }, \n}); \n \n const run = mainWorkflow. createRun (); \n const result = await run. start ({ \n triggerData: { \n inputData: ' test ', \n }, \n}); \n Advanced Example: Workflow Factory \n You can create a workflow factory that generates different workflows based on input parameters: \n \n const isMastra = (mastra: any): mastra is Mastra =&gt; { \n return mastra &amp;&amp; typeof mastra === ' object ' &amp;&amp; mastra instanceof Mastra; \n}; \n \n const workflowFactory = new Step ({ \n id: ' workflowFactory ', \n inputSchema: z. object ({ \n workflowType: z. enum ([ ' simple ', ' complex ']), \n inputData: z. string (), \n }), \n outputSchema: z. object ({ \n result: z. any (), \n }), \n execute: async ({ context, mastra }) =&gt; { \n if (! mastra) { \n throw new Error ( ' Mastra instance not available '); \n } \n \n if (! isMastra (mastra)) { \n throw new Error ( ' Invalid Mastra instance '); \n } \n \n // Create a new dynamic workflow based on the type \n const dynamicWorkflow = new Workflow ({ \n name: ` dynamic- ${ context.workflowType} -workflow `, \n mastra, \n triggerSchema: z. object ({ \n input: z. string (), \n }), \n }); \n \n if (context.workflowType === ' simple ') { \n // Simple workflow with a single step \n const simpleStep = new Step ({ \n id: ' simpleStep ', \n execute: async ({ context }) =&gt; { \n return { \n result: ` Simple processing: ${ context.triggerData.input}`, \n }; \n }, \n }); \n \n dynamicWorkflow. step (simpleStep). commit (); \n } else { \n // Complex workflow with multiple steps \n const step1 = new Step ({ \n id: ' step1 ', \n outputSchema: z. object ({ \n intermediateResult: z. string (), \n }), \n execute: async ({ context }) =&gt; { \n return { \n intermediateResult: ` First processing: ${ context.triggerData.input}`, \n }; \n }, \n }); \n \n const step2 = new Step ({ \n id: ' step2 ', \n execute: async ({ context }) =&gt; { \n const intermediate = context. getStepResult (step1).intermediateResult; \n return { \n finalResult: ` Second processing: ${ intermediate}`, \n }; \n }, \n }); \n \n dynamicWorkflow. step (step1). then (step2). commit (); \n } \n \n // Execute the dynamic workflow \n const run = dynamicWorkflow. createRun (); \n const result = await run. start ({ \n triggerData: { \n input: context.inputData, \n }, \n }); \n \n // Return the appropriate result based on workflow type \n if (context.workflowType === ' simple ') { \n return { \n // @ts-ignore \n result: result.results[ ' simpleStep ']?.output, \n }; \n } else { \n return { \n // @ts-ignore \n result: result.results[ ' step2 ']?.output, \n }; \n } \n }, \n}); \n Important Considerations \n \n \n Mastra Instance: The mastra parameter in the execute function provides access to the Mastra instance, which is essential for creating dynamic workflows. \n \n \n Error Handling: Always check if the Mastra instance is available before attempting to create a dynamic workflow. \n \n \n Resource Management: Dynamic workflows consume resources, so be mindful of creating too many workflows in a single execution. \n \n \n Workflow Lifecycle: Dynamic workflows are not automatically registered with the main Mastra instance. They exist only for the duration of the step execution unless you explicitly register them. \n \n \n Debugging: Debugging dynamic workflows can be challenging. Consider adding detailed logging to track their creation and execution. \n \n \n Use Cases \n \n Conditional Workflow Selection: Choose different workflow patterns based on input data \n Parameterized Workflows: Create workflows with dynamic configurations \n Workflow Templates: Use templates to generate specialized workflows \n Multi-tenant Applications: Create isolated workflows for different tenants \n \n Conclusion \n Dynamic workflows provide a powerful way to create flexible, adaptable workflow systems. By leveraging the Mastra instance within step execution, you can create workflows that respond to runtime conditions and requirements. Suspend &amp; Resume Error Handling",
    "image": "https://mastra.ai/api/og/docs?title=Dynamic%20Workflows%20|%20Mastra%20Docs&description=Learn%20how%20to%20create%20dynamic%20workflows%20within%20workflow%20steps,%20allowing%20for%20flexible%20workflow%20creation%20based%20on%20runtime%20conditions.",
    "favicon": "https://mastra.ai/favicon.ico",
    "extras": {
        "links": [
            "https://mastra.ai/en/docs/workflows/dynamic-workflows",
            "https://mastra.ai/",
            "https://mastra.ai/docs",
            "https://mastra.ai/examples"
        ]
    }
}