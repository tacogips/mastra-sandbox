{
    "id": "https://mastra.ai/docs/workflows-vnext/input-data-mapping",
    "title": "Input Data Mapping with Workflow (vNext) | Mastra Docs",
    "url": "https://mastra.ai/docs/workflows-vnext/input-data-mapping",
    "author": "",
    "text": "\n Input data mapping allows explicit mapping of values for the inputs of the next step. These values can come from a number of sources: \n \n The outputs of a previous step \n The runtime context \n A constant value \n The initial input of the workflow \n \n myWorkflow \n . then (step1) \n . map ({ \n transformedValue: { \n step: step1, \n path: \" nestedValue \", \n }, \n runtimeContextValue: { \n runtimeContextPath: \" runtimeContextValue \", \n schema: z. number (), \n }, \n constantValue: { \n value: 42, \n schema: z. number (), \n }, \n initDataValue: { \n initData: myWorkflow, \n path: \" startValue \", \n }, \n }) \n . then (step2) \n . commit (); \n There are many cases where.map() can be useful in matching inputs to outputs, whether itâ€™s renaming outputs to match inputs or mapping complex data structures or other previous step outputs. \n Renaming outputs \n One use case for input mappings is renaming outputs to match inputs: \n const step1 = createStep ({ \n id: \" step1 \", \n inputSchema: z. object ({ \n inputValue: z. string (), \n }), \n outputSchema: z. object ({ \n outputValue: z. string (), \n }), \n execute: async ({ inputData }) =&gt; { \n return { outputValue: inputData.inputValue }; \n }, \n}); \n \n const step2 = createStep ({ \n id: \" step2 \", \n inputSchema: z. object ({ \n unexpectedName: z. string (), \n }), \n outputSchema: z. object ({ \n result: z. string (), \n }), \n execute: async ({ inputData }) =&gt; { \n return { result: inputData.outputValue }; \n }, \n}); \n const workflow = createWorkflow ({ \n id: \" my-workflow \", \n steps: [step1, step2], \n inputSchema: z. object ({ \n inputValue: z. string (), \n }), \n outputSchema: z. object ({ \n result: z. string (), \n }), \n}); \n \n workflow \n . then (step1) \n . map ({ \n unexpectedName: { \n step: step1, \n path: \" outputValue \", \n }, \n }) \n . then (step2) \n . commit (); \n Using workflow inputs as later step inputs \n const step1 = createStep ({ \n id: \" step1 \", \n inputSchema: z. object ({ \n inputValue: z. string (), \n }), \n outputSchema: z. object ({ \n outputValue: z. string (), \n }), \n execute: async ({ inputData }) =&gt; { \n return { outputValue: inputData.inputValue }; \n }, \n}); \n \n const step2 = createStep ({ \n id: \" step2 \", \n inputSchema: z. object ({ \n outputValue: z. string (), \n initialValue: z. string (), \n }), \n outputSchema: z. object ({ \n result: z. string (), \n }), \n execute: async ({ inputData }) =&gt; { \n return { result: inputData.outputValue }; \n }, \n}); \n \n const workflow = createWorkflow ({ \n id: \" my-workflow \", \n steps: [step1, step2], \n inputSchema: z. object ({ \n inputValue: z. string (), \n }), \n outputSchema: z. object ({ \n result: z. string (), \n }), \n}); \n \n workflow \n . then (step1) \n . map ({ \n outputValue: { \n step: step1, \n path: \" outputValue \", \n }, \n initialValue: { \n initData: workflow, \n path: \" inputValue \", \n }, \n }) \n . then (step2) \n . commit (); \n Using multiple outputs of previous steps \n const step1 = createStep ({ \n id: \" step1 \", \n inputSchema: z. object ({ \n inputValue: z. string (), \n }), \n outputSchema: z. object ({ \n outputValue: z. string (), \n }), \n execute: async ({ inputData }) =&gt; { \n return { outputValue: inputData.inputValue }; \n }, \n}); \n \n const step2 = createStep ({ \n id: \" step2 \", \n inputSchema: z. object ({ \n outputValue: z. string (), \n initialValue: z. string (), \n }), \n outputSchema: z. object ({ \n result: z. string (), \n }), \n execute: async ({ inputData }) =&gt; { \n return { result: inputData.outputValue }; \n }, \n}); \n \n const step3 = createStep ({ \n id: \" step3 \", \n inputSchema: z. object ({ \n currentResult: z. string (), \n intermediateValue: z. string (), \n initialValue: z. string (), \n }), \n outputSchema: z. object ({ \n result: z. string (), \n }), \n execute: async ({ inputData }) =&gt; { \n return { \n result: \n inputData.result + \n \" \" + \n inputData.intermediateValue + \n \" \" + \n inputData.initialValue, \n }; \n }, \n}); \n \n const workflow = createWorkflow ({ \n id: \" my-workflow \", \n steps: [step1, step2], \n inputSchema: z. object ({ \n inputValue: z. string (), \n }), \n outputSchema: z. object ({ \n result: z. string (), \n }), \n}); \n \n workflow \n . then (step1) \n . then (step2) \n . map ({ \n initialValue: { \n initData: workflow, \n path: \" inputValue \", \n }, \n currentResult: { \n step: step2, \n path: \" result \", \n }, \n intermediateValue: { \n step: step1, \n path: \" outputValue \", \n }, \n }) \n . then (step3) \n . commit ();",
    "image": "https://mastra.ai/api/og/docs?title=Input%20Data%20Mapping%20with%20Workflow%20(vNext)%20|%20Mastra%20Docs&description=Learn%20how%20to%20use%20workflow%20input%20mapping%20to%20create%20more%20dynamic%20data%20flows%20in%20your%20Mastra%20workflows%20(vNext).",
    "favicon": "https://mastra.ai/favicon.ico",
    "extras": {
        "links": [
            "https://mastra.ai/en/docs/workflows-vnext/input-data-mapping",
            "https://mastra.ai/",
            "https://mastra.ai/docs",
            "https://mastra.ai/examples"
        ]
    }
}