{
    "id": "https://mastra.ai/docs/workflows/nested-workflows",
    "title": "Nested Workflows",
    "url": "https://mastra.ai/docs/workflows/nested-workflows",
    "author": "",
    "text": "\n Mastra allows you to use workflows as steps within other workflows, enabling you to create modular and reusable workflow components. This feature helps in organizing complex workflows into smaller, manageable pieces and promotes code reuse. \n It is also visually easier to understand the flow of a workflow when you can see the nested workflows as steps in the parent workflow. \n Basic Usage \n You can use a workflow as a step directly in another workflow using the step() method: \n // Create a nested workflow \n const nestedWorkflow = new Workflow ({ name: \" nested-workflow \" }) \n . step (stepA) \n . then (stepB) \n . commit (); \n \n // Use the nested workflow in a parent workflow \n const parentWorkflow = new Workflow ({ name: \" parent-workflow \" }) \n . step (nestedWorkflow, { \n variables: { \n city: { \n step: \" trigger \", \n path: \" myTriggerInput \", \n }, \n }, \n }) \n . then (stepC) \n . commit (); \n When a workflow is used as a step: \n \n It is automatically converted to a step using the workflow’s name as the step ID \n The workflow’s results are available in the parent workflow’s context \n The nested workflow’s steps are executed in their defined order \n \n Accessing Results \n Results from a nested workflow are available in the parent workflow’s context under the nested workflow’s name. The results include all step outputs from the nested workflow: \n const { results } = await parentWorkflow. start (); \n // Access nested workflow results \n const nestedWorkflowResult = results[ \" nested-workflow \"]; \n if (nestedWorkflowResult.status === \" success \") { \n const nestedResults = nestedWorkflowResult.output.results; \n} \n Control Flow with Nested Workflows \n Nested workflows support all the control flow features available to regular steps: \n Parallel Execution \n Multiple nested workflows can be executed in parallel: \n parentWorkflow \n . step (nestedWorkflowA) \n . step (nestedWorkflowB) \n . after ([nestedWorkflowA, nestedWorkflowB]) \n . step (finalStep); \n Or using step() with an array of workflows: \n parentWorkflow. step ([nestedWorkflowA, nestedWorkflowB]). then (finalStep); \n In this case, then() will implicitly wait for all the workflows to finish before executing the final step. \n If-Else Branching \n Nested workflows can be used in if-else branches using the new syntax that accepts both branches as arguments: \n // Create nested workflows for different paths \n const workflowA = new Workflow ({ name: \" workflow-a \" }) \n . step (stepA1) \n . then (stepA2) \n . commit (); \n \n const workflowB = new Workflow ({ name: \" workflow-b \" }) \n . step (stepB1) \n . then (stepB2) \n . commit (); \n \n // Use the new if-else syntax with nested workflows \n parentWorkflow \n . step (initialStep) \n . if ( \n async ({ context }) =&gt; { \n // Your condition here \n return someCondition; \n }, \n workflowA, // if branch \n workflowB, // else branch \n ) \n . then (finalStep) \n . commit (); \n The new syntax is more concise and clearer when working with nested workflows. When the condition is: \n \n true: The first workflow (if branch) is executed \n false: The second workflow (else branch) is executed \n \n The skipped workflow will have a status of skipped in the results: \n The.then(finalStep) call following the if-else block will merge the if and else branches back into a single execution path. \n Looping \n Nested workflows can use.until() and.while() loops same as any other step. One interesting new pattern is to pass a workflow directly as the loop-back argument to keep executing that nested workflow until something is true about its results: \n parentWorkflow \n . step (firstStep) \n . while ( \n ({ context }) =&gt; \n context. getStepResult ( \" nested-workflow \").output.results.someField === \n \" someValue \", \n nestedWorkflow, \n ) \n . step (finalStep) \n . commit (); \n Watching Nested Workflows \n You can watch the state changes of nested workflows using the watch method on the parent workflow. This is useful for monitoring the progress and state transitions of complex workflows: \n const parentWorkflow = new Workflow ({ name: \" parent-workflow \" }) \n . step ([nestedWorkflowA, nestedWorkflowB]) \n . then (finalStep) \n . commit (); \n \n const run = parentWorkflow. createRun (); \n const unwatch = parentWorkflow. watch ((state) =&gt; { \n console. log ( \" Current state: \", state.value); \n // Access nested workflow states in state.context \n}); \n \n await run. start (); \n unwatch (); // Stop watching when done \n Suspending and Resuming \n Nested workflows support suspension and resumption, allowing you to pause and continue workflow execution at specific points. You can suspend either the entire nested workflow or specific steps within it: \n // Define a step that may need to suspend \n const suspendableStep = new Step ({ \n id: \" other \", \n description: \" Step that may need to suspend \", \n execute: async ({ context, suspend }) =&gt; { \n if (! wasSuspended) { \n wasSuspended = true; \n await suspend (); \n } \n return { other: 26 }; \n }, \n}); \n \n // Create a nested workflow with suspendable steps \n const nestedWorkflow = new Workflow ({ name: \" nested-workflow-a \" }) \n . step (startStep) \n . then (suspendableStep) \n . then (finalStep) \n . commit (); \n \n // Use in parent workflow \n const parentWorkflow = new Workflow ({ name: \" parent-workflow \" }) \n . step (beginStep) \n . then (nestedWorkflow) \n . then (lastStep) \n . commit (); \n \n // Start the workflow \n const run = parentWorkflow. createRun (); \n const { runId, results } = await run. start ({ triggerData: { startValue: 1 } }); \n \n // Check if a specific step in the nested workflow is suspended \n if (results[ \" nested-workflow-a \"].output.results.other.status === \" suspended \") { \n // Resume the specific suspended step using dot notation \n const resumedResults = await run. resume ({ \n stepId: \" nested-workflow-a.other \", \n context: { startValue: 1 }, \n }); \n \n // The resumed results will contain the completed nested workflow \n expect (resumedResults.results[ \" nested-workflow-a \"].output.results). toEqual ({ \n start: { output: { newValue: 1 }, status: \" success \" }, \n other: { output: { other: 26 }, status: \" success \" }, \n final: { output: { finalValue: 27 }, status: \" success \" }, \n }); \n} \n When resuming a nested workflow: \n \n Use the nested workflow’s name as the stepId when calling resume() to resume the entire workflow \n Use dot notation ( nested-workflow.step-name) to resume a specific step within the nested workflow \n The nested workflow will continue from the suspended step with the provided context \n You can check the status of specific steps in the nested workflow’s results using results[\"nested-workflow\"].output.results \n \n Result Schemas and Mapping \n Nested workflows can define their result schema and mapping, which helps in type safety and data transformation. This is particularly useful when you want to ensure the nested workflow’s output matches a specific structure or when you need to transform the results before they’re used in the parent workflow. \n // Create a nested workflow with result schema and mapping \n const nestedWorkflow = new Workflow ({ \n name: \" nested-workflow \", \n result: { \n schema: z. object ({ \n total: z. number (), \n items: z. array ( \n z. object ({ \n id: z. string (), \n value: z. number (), \n }), \n ), \n }), \n mapping: { \n // Map values from step results using variables syntax \n total: { step: \" step-a \", path: \" count \" }, \n items: { step: \" step-b \", path: \" items \" }, \n }, \n }, \n}) \n . step (stepA) \n . then (stepB) \n . commit (); \n \n // Use in parent workflow with type-safe results \n const parentWorkflow = new Workflow ({ name: \" parent-workflow \" }) \n . step (nestedWorkflow) \n . then ( async ({ context }) =&gt; { \n const result = context. getStepResult ( \" nested-workflow \"); \n // TypeScript knows the structure of result \n console. log (result.total); // number \n console. log (result.items); // Array&lt;{ id: string, value: number }&gt; \n return { success: true }; \n }) \n . commit (); \n Best Practices \n \n Modularity: Use nested workflows to encapsulate related steps and create reusable workflow components. \n Naming: Give nested workflows descriptive names as they will be used as step IDs in the parent workflow. \n Error Handling: Nested workflows propagate their errors to the parent workflow, so handle errors appropriately. \n State Management: Each nested workflow maintains its own state but can access the parent workflow’s context. \n Suspension: When using suspension in nested workflows, consider the entire workflow’s state and handle resumption appropriately. \n \n Example \n Here’s a complete example showing various features of nested workflows: \n const workflowA = new Workflow ({ \n name: \" workflow-a \", \n result: { \n schema: z. object ({ \n activities: z. string (), \n }), \n mapping: { \n activities: { \n step: planActivities, \n path: \" activities \", \n }, \n }, \n }, \n}) \n . step (fetchWeather) \n . then (planActivities) \n . commit (); \n \n const workflowB = new Workflow ({ \n name: \" workflow-b \", \n result: { \n schema: z. object ({ \n activities: z. string (), \n }), \n mapping: { \n activities: { \n step: planActivities, \n path: \" activities \", \n }, \n }, \n }, \n}) \n . step (fetchWeather) \n . then (planActivities) \n . commit (); \n \n const weatherWorkflow = new Workflow ({ \n name: \" weather-workflow \", \n triggerSchema: z. object ({ \n cityA: z. string (). describe ( \" The city to get the weather for \"), \n cityB: z. string (). describe ( \" The city to get the weather for \"), \n }), \n result: { \n schema: z. object ({ \n activitiesA: z. string (), \n activitiesB: z. string (), \n }), \n mapping: { \n activitiesA: { \n step: workflowA, \n path: \" result.activities \", \n }, \n activitiesB: { \n step: workflowB, \n path: \" result.activities \", \n }, \n }, \n }, \n}) \n . step (workflowA, { \n variables: { \n city: { \n step: \" trigger \", \n path: \" cityA \", \n }, \n }, \n }) \n . step (workflowB, { \n variables: { \n city: { \n step: \" trigger \", \n path: \" cityB \", \n }, \n }, \n }); \n \n weatherWorkflow. commit (); \n In this example: \n \n We define schemas for type safety across all workflows \n Each step has proper input and output schemas \n The nested workflows have their own trigger schemas and result mappings \n Data is passed through using variables syntax in the.step() calls \n The main workflow combines data from both nested workflows \n",
    "image": "https://mastra.ai/api/og/docs?title=Nested%20Workflows&description=undefined",
    "favicon": "https://mastra.ai/favicon.ico",
    "extras": {
        "links": [
            "https://mastra.ai/en/docs/workflows/nested-workflows",
            "https://mastra.ai/",
            "https://mastra.ai/docs",
            "https://mastra.ai/examples"
        ]
    }
}