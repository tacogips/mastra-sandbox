{
    "id": "https://mastra.ai/examples/workflows_vNext/parallel-steps",
    "title": "Example: Parallel Execution | Workflows | Mastra Docs",
    "url": "https://mastra.ai/examples/workflows_vNext/parallel-steps",
    "publishedDate": "1999-10-01T00:00:00.000Z",
    "author": "",
    "text": "When building AI applications, you often need to process multiple independent tasks simultaneously to improve efficiency.\nWe make this functionality a core part of workflows through the.parallel method. Define a planning agent which leverages an LLM call to plan activities given a location and corresponding weather conditions. import { Agent } from ' @mastra/core/agent ' \n import { openai } from ' @ai-sdk/openai ' \n \n const llm = openai ( ' gpt-4o ') \n \n const planningAgent = new Agent ({ \n name: ' planningAgent ', \n model: llm, \n instructions: ` \n You are a local activities and travel expert who excels at weather-based planning. Analyze the weather data and provide practical activity recommendations. \n \n üìÖ [Day, Month Date, Year] \n ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê \n \n üå°Ô∏è WEATHER SUMMARY \n ‚Ä¢ Conditions: [brief description] \n ‚Ä¢ Temperature: [X¬∞C/Y¬∞F to A¬∞C/B¬∞F] \n ‚Ä¢ Precipitation: [X% chance] \n \n üåÖ MORNING ACTIVITIES \n Outdoor: \n ‚Ä¢ [Activity Name] - [Brief description including specific location/route] \n Best timing: [specific time range] \n Note: [relevant weather consideration] \n \n üåû AFTERNOON ACTIVITIES \n Outdoor: \n ‚Ä¢ [Activity Name] - [Brief description including specific location/route] \n Best timing: [specific time range] \n Note: [relevant weather consideration] \n \n üè† INDOOR ALTERNATIVES \n ‚Ä¢ [Activity Name] - [Brief description including specific venue] \n Ideal for: [weather condition that would trigger this alternative] \n \n ‚ö†Ô∏è SPECIAL CONSIDERATIONS \n ‚Ä¢ [Any relevant weather warnings, UV index, wind conditions, etc.] \n \n Guidelines: \n - Suggest 2-3 time-specific outdoor activities per day \n - Include 1-2 indoor backup options \n - For precipitation &gt;50%, lead with indoor activities \n - All activities must be specific to the location \n - Include specific venues, trails, or locations \n - Consider activity intensity based on temperature \n - Keep descriptions concise but informative \n \n Maintain this exact formatting for consistency, using the emoji and section headers as shown. \n `, \n}) \n \n export { planningAgent } Define a synthesize agent which takes planned indoor and outdoor activities and provides a full report on the day. agents/synthesize-agent.ts import { Agent } from ' @mastra/core/agent ' \n import { openai } from ' @ai-sdk/openai ' \n \n const llm = openai ( ' gpt-4o ') \n \n const synthesizeAgent = new Agent ({ \n name: ' synthesizeAgent ', \n model: llm, \n instructions: ` \n You are given two different blocks of text, one about indoor activities and one about outdoor activities. \n Make this into a full report about the day and the possibilities depending on whether it rains or not. \n `, \n}) \n \n export { synthesizeAgent } Here, we‚Äôll define a workflow which orchestrates a parallel -&gt; sequential flow between the planning steps and the synthesize step. workflows/parallel-workflow.ts import { Step, Workflow } from ' @mastra/core/workflows ' \n import { z } from ' zod ' \n import { activityPlannerAgent } from '../agents ' \n import { createStep, createWorkflow } from ' @mastra/core/workflows/vNext ' \n \n const forecastSchema = z. object ({ \n date: z. string (), \n maxTemp: z. number (), \n minTemp: z. number (), \n precipitationChance: z. number (), \n condition: z. string (), \n location: z. string (), \n}) \n \n const fetchWeather = createStep ({ \n id: ' fetch-weather ', \n description: ' Fetches weather forecast for a given city ', \n inputSchema: z. object ({ \n city: z. string (), \n }), \n outputSchema: forecastSchema, \n execute: async ({ inputData }) =&gt; { \n if (! inputData) { \n throw new Error ( ' Trigger data not found ') \n } \n \n const geocodingUrl = ` https://geocoding-api.open-meteo.com/v1/search?name= ${ encodeURIComponent (inputData.city)} &amp;count=1 ` \n const geocodingResponse = await fetch (geocodingUrl) \n const geocodingData = ( await geocodingResponse. json ()) as { \n results: { latitude: number; longitude: number; name: string }[] \n } \n \n if (! geocodingData.results?.[ 0]) { \n throw new Error ( ` Location ' ${ inputData.city} ' not found `) \n } \n \n const { latitude, longitude, name } = geocodingData.results[ 0] \n \n const weatherUrl = ` https://api.open-meteo.com/v1/forecast?latitude= ${ latitude} &amp;longitude= ${ longitude} &amp;current=precipitation,weathercode&amp;timezone=auto,&amp;hourly=precipitation_probability,temperature_2m ` \n const response = await fetch (weatherUrl) \n const data = ( await response. json ()) as { \n current: { \n time: string \n precipitation: number \n weathercode: number \n } \n hourly: { \n precipitation_probability: number [] \n temperature_2m: number [] \n } \n } \n \n const forecast = { \n date: new Date (). toISOString (), \n maxTemp: Math. max (... data.hourly.temperature_2m), \n minTemp: Math. min (... data.hourly.temperature_2m), \n condition: getWeatherCondition (data.current.weathercode), \n location: name, \n precipitationChance: data.hourly.precipitation_probability. reduce ( \n (acc, curr) =&gt; Math. max (acc, curr), \n 0 \n ), \n } \n \n return forecast \n }, \n}) \n \n const planActivities = createStep ({ \n id: ' plan-activities ', \n description: ' Suggests activities based on weather conditions ', \n inputSchema: forecastSchema, \n outputSchema: z. object ({ \n activities: z. string (), \n }), \n execute: async ({ inputData, mastra }) =&gt; { \n console. log ( ' mastra ', mastra) \n console. log ( ' planActivities ', inputData) \n const forecast = inputData \n \n if (! forecast) { \n throw new Error ( ' Forecast data not found ') \n } \n \n const prompt = ` Based on the following weather forecast for ${ forecast.location}, suggest appropriate activities: \n ${ JSON. stringify (forecast, null, 2)} \n ` \n \n const agent = mastra?. getAgent ( ' planningAgent ') \n if (! agent) { \n throw new Error ( ' Planning agent not found ') \n } \n \n const response = await agent. stream ([ \n { \n role: ' user ', \n content: prompt, \n }, \n ]) \n \n let activitiesText = '' \n \n for await ( const chunk of response.textStream) { \n process.stdout. write (chunk) \n activitiesText += chunk \n } \n \n console. log ( ' planActivities ', activitiesText) \n \n return { \n activities: activitiesText, \n } \n }, \n}) \n \n function getWeatherCondition (code: number): string { \n const conditions: Record &lt; number, string &gt; = { \n 0: ' Clear sky ', \n 1: ' Mainly clear ', \n 2: ' Partly cloudy ', \n 3: ' Overcast ', \n 45: ' Foggy ', \n 48: ' Depositing rime fog ', \n 51: ' Light drizzle ', \n 53: ' Moderate drizzle ', \n 55: ' Dense drizzle ', \n 61: ' Slight rain ', \n 63: ' Moderate rain ', \n 65: ' Heavy rain ', \n 71: ' Slight snow fall ', \n 73: ' Moderate snow fall ', \n 75: ' Heavy snow fall ', \n 95: ' Thunderstorm ', \n } \n return conditions[code] || ' Unknown ' \n} \n \n const planIndoorActivities = createStep ({ \n id: ' plan-indoor-activities ', \n description: ' Suggests indoor activities based on weather conditions ', \n inputSchema: forecastSchema, \n outputSchema: z. object ({ \n activities: z. string (), \n }), \n execute: async ({ inputData, mastra }) =&gt; { \n console. log ( ' planIndoorActivities ', inputData) \n const forecast = inputData \n \n if (! forecast) { \n throw new Error ( ' Forecast data not found ') \n } \n \n const prompt = ` In case it rains, plan indoor activities for ${ forecast.location} on ${ forecast.date}` \n \n const agent = mastra?. getAgent ( ' planningAgent ') \n if (! agent) { \n throw new Error ( ' Planning agent not found ') \n } \n \n const response = await agent. stream ([ \n { \n role: ' user ', \n content: prompt, \n }, \n ]) \n \n let activitiesText = '' \n \n for await ( const chunk of response.textStream) { \n activitiesText += chunk \n } \n \n console. log ( ' planIndoorActivities ', activitiesText) \n return { \n activities: activitiesText, \n } \n }, \n}) \n \n const sythesizeStep = createStep ({ \n id: ' sythesize-step ', \n description: ' Synthesizes the results of the indoor and outdoor activities ', \n inputSchema: z. object ({ \n ' plan-activities ': z. object ({ \n activities: z. string (), \n }), \n ' plan-indoor-activities ': z. object ({ \n activities: z. string (), \n }), \n }), \n outputSchema: z. object ({ \n activities: z. string (), \n }), \n execute: async ({ inputData, mastra }) =&gt; { \n console. log ( ' sythesizeStep ', inputData) \n const indoorActivities = inputData?.[ ' plan-indoor-activities '] \n const outdoorActivities = inputData?.[ ' plan-activities '] \n \n const prompt = ` Indoor activtities: \n ${ indoorActivities?.activities} \n \n Outdoor activities: \n ${ outdoorActivities?.activities} \n \n There is a chance of rain so be prepared to do indoor activities if needed. ` \n \n const agent = mastra?. getAgent ( ' synthesizeAgent ') \n if (! agent) { \n throw new Error ( ' Planning agent not found ') \n } \n \n const response = await agent. stream ([ \n { \n role: ' user ', \n content: prompt, \n }, \n ]) \n \n let activitiesText = '' \n \n for await ( const chunk of response.textStream) { \n process.stdout. write (chunk) \n activitiesText += chunk \n } \n \n return { \n activities: activitiesText, \n } \n }, \n}) \n \n const weatherWorkflow = createWorkflow ({ \n id: ' plan-both-workflow ', \n inputSchema: forecastSchema, \n outputSchema: z. object ({ \n activities: z. string (), \n }), \n steps: [planActivities, planIndoorActivities, sythesizeStep], \n}) \n // run `planActivities` and `planIndoorActivities` in parallel \n // `synthesizeStep` waits for both steps to be completed before executing. \n . parallel ([planActivities, planIndoorActivities]) \n . then (sythesizeStep) \n . commit () \n \n export { weatherWorkflow } Register the agents and workflow with the mastra instance.\nThis is critical for enabling access to the agents within the workflow. import { Mastra } from ' @mastra/core/mastra ' \n import { createLogger } from ' @mastra/core/logger ' \n import { weatherWorkflow } from './workflows ' \n import { planningAgent, synthesizeAgent } from './agents ' \n \n const mastra = new Mastra ({ \n vnext_workflows: { \n weatherWorkflow, \n }, \n agents: { \n planningAgent, \n synthesizeAgent \n }, \n logger: createLogger ({ \n name: ' Mastra ', \n level: ' info ', \n }), \n}) \n \n export { mastra } Here, we‚Äôll get the weather workflow from the mastra instance, then create a run and execute the created run with the required inputData. import { mastra } from \"./ \" \n \n const workflow = mastra. vnext_getWorkflow ( ' weatherWorkflow ') \n const run = workflow. createRun () \n \n const result = await run. start ({ inputData: { city: ' Ibiza ' } }) \n console. dir (result, { depth: null })",
    "image": "https://mastra.ai/api/og/docs?title=Example:%20Parallel%20Execution%20|%20Workflows%20|%20Mastra%20Docs&description=Example%20of%20using%20Mastra%20to%20execute%20multiple%20independent%20tasks%20in%20parallel%20within%20a%20workflow.",
    "favicon": "https://mastra.ai/favicon.ico",
    "extras": {
        "links": [
            "https://mastra.ai/en/examples/workflows_vNext/parallel-steps",
            "https://mastra.ai/",
            "https://mastra.ai/docs",
            "https://mastra.ai/examples"
        ]
    }
}