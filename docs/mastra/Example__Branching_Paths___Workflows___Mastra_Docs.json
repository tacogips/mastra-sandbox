{
    "id": "https://mastra.ai/examples/workflows/branching-paths",
    "title": "Example: Branching Paths | Workflows | Mastra Docs",
    "url": "https://mastra.ai/examples/workflows/branching-paths",
    "publishedDate": "",
    "author": "",
    "text": "\n When processing data, you often need to take different actions based on intermediate results. This example shows how to create a workflow that splits into separate paths, where each path executes different steps based on the output of a previous step. \n Control Flow Diagram \n This example shows how to create a workflow that splits into separate paths, where each path executes different steps based on the output of a previous step. \n Here’s the control flow diagram: \n Creating the Steps \n Let’s start by creating the steps and initializing the workflow. \n import { Step, Workflow } from \" @mastra/core/workflows \"; \n import { z } from \" zod \" \n \n const stepOne = new Step ({ \n id: \" stepOne \", \n execute: async ({ context }) =&gt; ({ \n doubledValue: context.triggerData.inputValue * 2 \n }) \n}); \n \n const stepTwo = new Step ({ \n id: \" stepTwo \", \n execute: async ({ context }) =&gt; { \n const stepOneResult = context. getStepResult &lt;{ doubledValue: number }&gt;( \" stepOne \"); \n if (! stepOneResult) { \n return { isDivisibleByFive: false } \n } \n \n return { isDivisibleByFive: stepOneResult.doubledValue % 5 === 0 } \n } \n}); \n \n \n const stepThree = new Step ({ \n id: \" stepThree \", \n execute: async ({ context }) =&gt; { \n const stepOneResult = context. getStepResult &lt;{ doubledValue: number }&gt;( \" stepOne \"); \n if (! stepOneResult) { \n return { incrementedValue: 0 } \n } \n \n return { incrementedValue: stepOneResult.doubledValue + 1 } \n } \n}); \n \n const stepFour = new Step ({ \n id: \" stepFour \", \n execute: async ({ context }) =&gt; { \n const stepThreeResult = context. getStepResult &lt;{ incrementedValue: number }&gt;( \" stepThree \"); \n if (! stepThreeResult) { \n return { isDivisibleByThree: false } \n } \n \n return { isDivisibleByThree: stepThreeResult.incrementedValue % 3 === 0 } \n } \n}); \n \n // New step that depends on both branches \n const finalStep = new Step ({ \n id: \" finalStep \", \n execute: async ({ context }) =&gt; { \n // Get results from both branches using getStepResult \n const stepTwoResult = context. getStepResult &lt;{ isDivisibleByFive: boolean }&gt;( \" stepTwo \"); \n const stepFourResult = context. getStepResult &lt;{ isDivisibleByThree: boolean }&gt;( \" stepFour \"); \n \n const isDivisibleByFive = stepTwoResult?.isDivisibleByFive || false; \n const isDivisibleByThree = stepFourResult?.isDivisibleByThree || false; \n \n return { \n summary: ` The number ${ context.triggerData.inputValue} when doubled ${ isDivisibleByFive ? ' is ' : ' is not '} divisible by 5, and when doubled and incremented ${ isDivisibleByThree ? ' is ' : ' is not '} divisible by 3. `, \n isDivisibleByFive, \n isDivisibleByThree \n } \n } \n}); \n \n // Build the workflow \n const myWorkflow = new Workflow ({ \n name: \" my-workflow \", \n triggerSchema: z. object ({ \n inputValue: z. number (), \n }), \n}); \n Branching Paths and Chaining Steps \n Now let’s configure the workflow with branching paths and merge them using the compound.after([]) syntax. \n // Create two parallel branches \n myWorkflow \n // First branch \n . step (stepOne) \n . then (stepTwo) \n \n // Second branch \n . after (stepOne) \n . step (stepThree) \n . then (stepFour) \n \n // Merge both branches using compound after syntax \n . after ([stepTwo, stepFour]) \n . step (finalStep) \n . commit (); \n \n const { start } = myWorkflow. createRun (); \n \n const result = await start ({ triggerData: { inputValue: 3 } }); \n console. log (result.steps.finalStep.output.summary); \n // Output: \"The number 3 when doubled is not divisible by 5, and when doubled and incremented is divisible by 3.\" \n Advanced Branching and Merging \n You can create more complex workflows with multiple branches and merge points: \n const complexWorkflow = new Workflow ({ \n name: \" complex-workflow \", \n triggerSchema: z. object ({ \n inputValue: z. number (), \n }), \n}); \n \n // Create multiple branches with different merge points \n complexWorkflow \n // Main step \n . step (stepOne) \n \n // First branch \n . then (stepTwo) \n \n // Second branch \n . after (stepOne) \n . step (stepThree) \n . then (stepFour) \n \n // Third branch (another path from stepOne) \n . after (stepOne) \n . step ( new Step ({ \n id: \" alternativePath \", \n execute: async ({ context }) =&gt; { \n const stepOneResult = context. getStepResult &lt;{ doubledValue: number }&gt;( \" stepOne \"); \n return { \n result: (stepOneResult?.doubledValue || 0) * 3 \n } \n } \n })) \n \n // Merge first and second branches \n . after ([stepTwo, stepFour]) \n . step ( new Step ({ \n id: \" partialMerge \", \n execute: async ({ context }) =&gt; { \n const stepTwoResult = context. getStepResult &lt;{ isDivisibleByFive: boolean }&gt;( \" stepTwo \"); \n const stepFourResult = context. getStepResult &lt;{ isDivisibleByThree: boolean }&gt;( \" stepFour \"); \n \n return { \n intermediateResult: \" Processed first two branches \", \n branchResults: { \n branch1: stepTwoResult?.isDivisibleByFive, \n branch2: stepFourResult?.isDivisibleByThree \n } \n } \n } \n })) \n \n // Final merge of all branches \n . after ([ \" partialMerge \", \" alternativePath \"]) \n . step ( new Step ({ \n id: \" finalMerge \", \n execute: async ({ context }) =&gt; { \n const partialMergeResult = context. getStepResult &lt;{ \n intermediateResult: string, \n branchResults: { branch1: boolean, branch2: boolean } \n }&gt;( \" partialMerge \"); \n \n const alternativePathResult = context. getStepResult &lt;{ result: number }&gt;( \" alternativePath \"); \n \n return { \n finalResult: \" All branches processed \", \n combinedData: { \n fromPartialMerge: partialMergeResult?.branchResults, \n fromAlternativePath: alternativePathResult?.result \n } \n } \n } \n })) \n . commit (); \n \n Parallel Steps Conditional Branching",
    "image": "https://mastra.ai/api/og/docs?title=Example:%20Branching%20Paths%20|%20Workflows%20|%20Mastra%20Docs&description=Example%20of%20using%20Mastra%20to%20create%20workflows%20with%20branching%20paths%20based%20on%20intermediate%20results.",
    "favicon": "https://mastra.ai/favicon.ico",
    "extras": {
        "links": [
            "https://mastra.ai/en/examples/workflows/branching-paths",
            "https://mastra.ai/",
            "https://mastra.ai/docs",
            "https://mastra.ai/examples"
        ]
    }
}