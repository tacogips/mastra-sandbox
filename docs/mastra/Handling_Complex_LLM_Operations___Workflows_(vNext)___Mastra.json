{
    "id": "https://mastra.ai/docs/workflows-vnext/overview",
    "title": "Handling Complex LLM Operations | Workflows (vNext) | Mastra",
    "url": "https://mastra.ai/docs/workflows-vnext/overview",
    "author": "",
    "text": "Getting Started \n To use vNext workflows, first import the necessary functions from the vNext module: \n import { createWorkflow, createStep } from \" @mastra/core/workflows/vNext \"; \n import { z } from \" zod \"; // For schema validation \n Key Concepts \n vNext workflows consist of: \n \n Schemas: Type definitions for inputs and outputs using Zod \n Steps: Individual units of work with defined inputs and outputs \n Workflows: Orchestrations of steps with defined execution patterns. A workflow is also a step and can be used as such in other workflows. \n Workflow execution flow: How steps are executed and connected to each other \n \n Schemas are defined using Zod both for inputs and outputs of steps and workflows. Schemas can also dictate what data does a step take when resuming from a suspended state, as well as what contextual information should be passed when suspending a step’s execution. \n The inputs and outputs of steps that are connected together should match: the inputSchema of a step should be the same as the outputSchema of the previous step, for instance. The same is true, when using workflows as steps in other workflows, the workflow’s inputSchema should match the outputSchema of the step it is used as. \n Steps are run using an execute function that receives a context object with inputs from the previous step and/or resume data if the step is being resumed from a suspended state. The execute function should return a value that matches its outputSchema. \n Primitives such as.then(),.parallel() and.branch() describe the execution flow of workflows, and how the steps within them are connected. Running workflows (whether standalone or as a step), their execution is dictated by their execution flow instead of an execute function. The final result of a workflow will always be the result of its last step, which should match the workflow’s outputSchema. \n Creating Workflows \n Steps \n Steps are the building blocks of workflows. Create a step using createStep: \n const myStep = createStep ({ \n id: \" my-step \", \n description: \" Does something useful \", \n inputSchema: z. object ({ \n inputValue: z. string (), \n }), \n outputSchema: z. object ({ \n outputValue: z. string (), \n }), \n resumeSchema: z. object ({ \n resumeValue: z. string (), \n }), \n suspendSchema: z. object ({ \n suspendValue: z. string (), \n }), \n execute: async ({ \n inputData, \n mastra, \n getStepResult, \n getInitData, \n runtimeContext, \n }) =&gt; { \n const otherStepOutput = getStepResult (step2); \n const initData = getInitData &lt; typeof workflow&gt;(); // typed as the workflow input schema \n return { \n outputValue: ` Processed: ${ inputData.inputValue}, ${ initData.startValue} (runtimeContextValue: ${ runtimeContext. get ( \" runtimeContextValue \")}) `, \n }; \n }, \n}); \n Each step requires: \n \n id: Unique identifier for the step \n inputSchema: Zod schema defining expected input \n outputSchema: Zod schema defining output shape \n resumeSchema: Optional. Zod schema defining resume input \n suspendSchema: Optional. Zod schema defining suspend input \n execute: Async function that performs the step’s work \n \n The execute function receives a context object with: \n \n inputData: The input data matching the inputSchema \n resumeData: The resume data matching the resumeSchema, when resuming the step from a suspended state. Only exists if the step is being resumed. \n mastra: Access to mastra services (agents, tools, etc.) \n getStepResult: Function to access results from other steps \n getInitData: Function to access the initial input data of the workflow in any step \n suspend: Function to pause workflow execution (for user interaction) \n \n Workflow Structure \n Create a workflow using createWorkflow: \n const myWorkflow = createWorkflow ({ \n id: \" my-workflow \", \n inputSchema: z. object ({ \n startValue: z. string (), \n }), \n outputSchema: z. object ({ \n result: z. string (), \n }), \n steps: [step1, step2, step3], // Declare steps used in this workflow \n}); \n \n const mastra = new Mastra ({ \n vnext_workflows: { \n myWorkflow, \n }, \n}); \n \n const run = mastra. vnext_getWorkflow ( \" myWorkflow \"). createRun (); \n The steps property in the workflow options provides type safety for accessing step results. When you declare the steps used in your workflow, TypeScript will ensure type safety when accessing result.steps: \n // With steps declared in workflow options \n const workflow = createWorkflow ({ \n id: \" my-workflow \", \n inputSchema: z. object ({}), \n outputSchema: z. object ({}), \n steps: [step1, step2], // TypeScript knows these steps exist \n}); \n \n const result = await workflow. createRun (). start ({ inputData: {} }); \n if (result.status === \" success \") { \n console. log (result.result); // only exists if status is success \n} else if (result.status === \" failed \") { \n console. error (result.error); // only exists if status is failed, this is an instance of Error \n throw result.error; \n} else if (result.status === \" suspended \") { \n console. log (result.suspended); // only exists if status is suspended \n} \n \n // TypeScript knows these properties exist and their types \n console. log (result.steps.step1.output); // Fully typed \n console. log (result.steps.step2.output); // Fully typed \n Workflow definition requires: \n \n id: Unique identifier for the workflow \n inputSchema: Zod schema defining workflow input \n outputSchema: Zod schema defining workflow output \n steps: Array of steps used in the workflow (optional, but recommended for type safety) \n \n Re-using steps and nested workflows \n You can re-use steps and nested workflows by cloning them: \n const clonedStep = cloneStep (myStep, { id: \" cloned-step \" }); \n const clonedWorkflow = cloneWorkflow (myWorkflow, { id: \" cloned-workflow \" }); \n This way you can use the same step or nested workflow in the same workflow multiple times. \n import { \n createWorkflow, \n createStep, \n cloneStep, \n cloneWorkflow, \n} from \" @mastra/core/workflows/vNext \"; \n \n const myWorkflow = createWorkflow ({ \n id: \" my-workflow \", \n steps: [step1, step2, step3], \n}); \n myWorkflow. then (step1). then (step2). then (step3). commit (); \n \n const parentWorkflow = createWorkflow ({ \n id: \" parent-workflow \", \n steps: [myWorkflow, step4], \n}); \n parentWorkflow \n . then (myWorkflow) \n . then (step4) \n . then ( cloneWorkflow (myWorkflow, { id: \" cloned-workflow \" })) \n . then ( cloneStep (step4, { id: \" cloned-step-4 \" })) \n . commit (); \n Running Workflows \n After defining a workflow, run it with: \n // Create a run instance \n const run = myWorkflow. createRun (); \n \n // Start the workflow with input data \n const result = await run. start ({ \n inputData: { \n startValue: \" initial data \", \n }, \n}); \n \n // Access the results \n console. log (result.steps); // All step results \n console. log (result.steps[ \" step-id \"].output); // Output from a specific step \n \n if (result.status === \" success \") { \n console. log (result.result); // The final result of the workflow, result of the last step (or `.map()` output, if used as last step) \n} else if (result.status === \" suspended \") { \n const resumeResult = await run. resume ({ \n step: result.suspended[ 0], // there is always at least one step id in the suspended array, in this case we resume the first suspended execution path \n resumeData: { \n /* user input */ \n }, \n }); \n} else if (result.status === \" failed \") { \n console. error (result.error); // only exists if status is failed, this is an instance of Error \n} \n Workflow Execution Result Schema \n The result of running a workflow (either from start() or resume()) follows this TypeScript interface: \n export type WorkflowResult &lt;... &gt; = \n | { \n status: ' success '; \n result: z. infer &lt; TOutput &gt;; \n steps: { \n [ K in keyof StepsRecord &lt; TSteps &gt;]: StepsRecord &lt; TSteps &gt;[ K][ ' outputSchema '] extends undefined \n ? StepResult &lt; unknown &gt; \n : StepResult &lt; z. infer &lt; NonNullable &lt; StepsRecord &lt; TSteps &gt;[ K][ ' outputSchema ']&gt;&gt;&gt;; \n }; \n } \n | { \n status: ' failed '; \n steps: { \n [ K in keyof StepsRecord &lt; TSteps &gt;]: StepsRecord &lt; TSteps &gt;[ K][ ' outputSchema '] extends undefined \n ? StepResult &lt; unknown &gt; \n : StepResult &lt; z. infer &lt; NonNullable &lt; StepsRecord &lt; TSteps &gt;[ K][ ' outputSchema ']&gt;&gt;&gt;; \n }; \n error: Error; \n } \n | { \n status: ' suspended '; \n steps: { \n [ K in keyof StepsRecord &lt; TSteps &gt;]: StepsRecord &lt; TSteps &gt;[ K][ ' outputSchema '] extends undefined \n ? StepResult &lt; unknown &gt; \n : StepResult &lt; z. infer &lt; NonNullable &lt; StepsRecord &lt; TSteps &gt;[ K][ ' outputSchema ']&gt;&gt;&gt;; \n }; \n suspended: [ string [], ...string [][]]; \n }; \n Result Properties Explained \n \n \n status: Indicates the final state of the workflow execution \n \n 'success': Workflow completed successfully \n 'failed': Workflow encountered an error \n 'suspended': Workflow is paused waiting for user input \n \n \n \n result: Contains the final output of the workflow, typed according to the workflow’s outputSchema \n \n \n suspended: Optional array of step IDs that are currently suspended. Only present when status is 'suspended' \n \n \n steps: A record containing the results of all executed steps \n \n Keys are step IDs \n Values are StepResult objects containing the step’s output \n Type-safe based on each step’s outputSchema \n \n \n \n error: Optional error object present when status is 'failed' \n \n \n Watching Workflow Execution \n You can also watch workflow execution: \n const run = myWorkflow. createRun (); \n \n // Add a watcher to monitor execution \n run. watch (event =&gt; { \n console. log ( ' Step completed: ', event.payload.currentStep.id); \n}); \n \n // Start the workflow \n const result = await run. start ({ inputData: {...} }); \n The event object has the following schema: \n type WatchEvent = { \n type: \" watch \"; \n payload: { \n currentStep?: { \n id: string; \n status: \" running \" | \" completed \" | \" failed \" | \" suspended \"; \n output?: Record &lt; string, any &gt;; \n payload?: Record &lt; string, any &gt;; \n }; \n workflowState: { \n status: \" running \" | \" success \" | \" failed \" | \" suspended \"; \n steps: Record &lt; \n string, \n { \n status: \" running \" | \" completed \" | \" failed \" | \" suspended \"; \n output?: Record &lt; string, any &gt;; \n payload?: Record &lt; string, any &gt;; \n } \n &gt;; \n result?: Record &lt; string, any &gt;; \n error?: Record &lt; string, any &gt;; \n payload?: Record &lt; string, any &gt;; \n }; \n }; \n eventTimestamp: Date; \n}; \n The currentStep property is only present when the workflow is running. When the workflow is finished the status on workflowState is changed, as well as the result and error properties. At the same time the currentStep property is removed.",
    "image": "https://mastra.ai/api/og/docs?title=Handling%20Complex%20LLM%20Operations%20|%20Workflows%20(vNext)%20|%20Mastra&description=Workflows%20(vNext)%20in%20Mastra%20help%20you%20orchestrate%20complex%20sequences%20of%20operations%20with%20features%20like%20branching,%20parallel%20execution,%20resource%20suspension,%20and%20more.",
    "favicon": "https://mastra.ai/favicon.ico",
    "extras": {
        "links": [
            "https://mastra.ai/en/docs/workflows-vnext/overview",
            "https://mastra.ai/",
            "https://mastra.ai/docs",
            "https://mastra.ai/examples"
        ]
    }
}