{
    "id": "https://mastra.ai/docs/tools-mcp/dynamic-context",
    "title": "Dynamic Tool Context | Tools & MCP | Mastra Docs",
    "url": "https://mastra.ai/docs/tools-mcp/dynamic-context",
    "author": "",
    "text": "\n Mastra provides RuntimeContext, a system based on dependency injection, that allows you to pass dynamic, request-specific configuration to your tools during execution. This is useful when a toolâ€™s behavior needs to change based on user identity, request headers, or other runtime factors, without altering the toolâ€™s core code. \n ðŸ’¡ Note: RuntimeContext is primarily used for passing data into tool executions. Itâ€™s distinct from agent memory, which handles conversation history and state persistence across multiple calls. \n Basic Usage \n To use RuntimeContext, first define a type structure for your dynamic configuration. Then, create an instance of RuntimeContext typed with your definition and set the desired values. Finally, include the runtimeContext instance in the options object when calling agent.generate() or agent.stream(). \n import { RuntimeContext } from \" @mastra/core/di \"; \n // Assume 'agent' is an already defined Mastra Agent instance \n \n // Define the context type \n type WeatherRuntimeContext = { \n \" temperature-scale \": \" celsius \" | \" fahrenheit \"; \n}; \n \n // Instantiate RuntimeContext and set values \n const runtimeContext = new RuntimeContext &lt; WeatherRuntimeContext &gt;(); \n runtimeContext. set ( \" temperature-scale \", \" celsius \"); \n \n // Pass to agent call \n const response = await agent. generate ( \" What's the weather like today? \", { \n runtimeContext, // Pass the context here \n}); \n \n console. log (response.text); \n Accessing Context in Tools \n Tools receive the runtimeContext as part of the second argument to their execute function. You can then use the.get() method to retrieve values. \n src/mastra/tools/weather-tool.ts import { createTool } from \" @mastra/core/tools \"; \n import { z } from \" zod \"; \n // Assume WeatherRuntimeContext is defined as above and accessible here \n \n // Dummy fetch function \n async function fetchWeather ( \n location: string, \n options: { temperatureUnit: \" celsius \" | \" fahrenheit \" } \n): Promise &lt; any &gt; { \n console. log ( ` Fetching weather for ${ location} in ${ options.temperatureUnit}`); \n // Replace with actual API call \n return { temperature: options.temperatureUnit === \" celsius \" ? 20 : 68 }; \n} \n \n export const weatherTool = createTool ({ \n id: \" getWeather \", \n description: \" Get the current weather for a location \", \n inputSchema: z. object ({ \n location: z. string (). describe ( \" The location to get weather for \"), \n }), \n // The tool's execute function receives runtimeContext \n execute: async ({ context, runtimeContext }) =&gt; { \n // Type-safe access to runtimeContext variables \n const temperatureUnit = runtimeContext. get ( \" temperature-scale \"); \n \n // Use the context value in the tool logic \n const weather = await fetchWeather (context.location, { \n temperatureUnit, \n }); \n \n return { result: ` The temperature is ${ weather.temperature} Â° ${ temperatureUnit === \" celsius \" ? \" C \" : \" F \"}` }; \n }, \n}); \n When the agent uses weatherTool, the temperature-scale value set in the runtimeContext during the agent.generate() call will be available inside the toolâ€™s execute function. \n Using with Server Middleware \n In server environments (like Express or Next.js), you can use middleware to automatically populate RuntimeContext based on incoming request data, such as headers or user sessions. \n Hereâ€™s an example using Mastraâ€™s built-in server middleware support (which uses Hono internally) to set the temperature scale based on the Cloudflare CF-IPCountry header: \n import { Mastra } from \" @mastra/core \"; \n import { RuntimeContext } from \" @mastra/core/di \"; \n import { weatherAgent } from \"./agents/weather \"; // Assume agent is defined elsewhere \n \n // Define RuntimeContext type \n type WeatherRuntimeContext = { \n \" temperature-scale \": \" celsius \" | \" fahrenheit \"; \n}; \n \n export const mastra = new Mastra ({ \n agents: { \n weather: weatherAgent, \n }, \n server: { \n middleware: [ \n async (c, next) =&gt; { \n // Get the RuntimeContext instance \n const runtimeContext = c. get &lt; RuntimeContext &lt; WeatherRuntimeContext &gt;&gt;( \" runtimeContext \"); \n \n // Get country code from request header \n const country = c.req. header ( \" CF-IPCountry \"); \n \n // Set temperature scale based on country \n runtimeContext. set ( \n \" temperature-scale \", \n country === \" US \" ? \" fahrenheit \" : \" celsius \", \n ); \n \n // Continue request processing \n await next (); \n }, \n ], \n }, \n}); \n With this middleware in place, any agent call handled by this Mastra server instance will automatically have the temperature-scale set in its RuntimeContext based on the userâ€™s inferred country, and tools like weatherTool will use it accordingly.",
    "image": "https://mastra.ai/api/og/docs?title=Dynamic%20Tool%20Context%20|%20Tools%20&%20MCP%20|%20Mastra%20Docs&description=Learn%20how%20to%20use%20Mastra%27s%20RuntimeContext%20to%20provide%20dynamic,%20request-specific%20configuration%20to%20tools.",
    "favicon": "https://mastra.ai/favicon.ico",
    "extras": {
        "links": [
            "https://mastra.ai/en/docs/tools-mcp/dynamic-context",
            "https://mastra.ai/",
            "https://mastra.ai/docs",
            "https://mastra.ai/examples"
        ]
    }
}