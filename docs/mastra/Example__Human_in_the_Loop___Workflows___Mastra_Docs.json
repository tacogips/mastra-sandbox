{
    "id": "https://mastra.ai/examples/workflows/human-in-the-loop",
    "title": "Example: Human in the Loop | Workflows | Mastra Docs",
    "url": "https://mastra.ai/examples/workflows/human-in-the-loop",
    "publishedDate": "",
    "author": "",
    "text": "Human in the Loop Workflow \n Human-in-the-loop workflows allow you to pause execution at specific points to collect user input, make decisions, or perform actions that require human judgment. This example demonstrates how to create a workflow with human intervention points. \n How It Works \n \n A workflow step can suspend execution using the suspend() function, optionally passing a payload with context for the human decision maker. \n When the workflow is resumed, the human input is passed in the context parameter of the resume() call. \n This input becomes available in the step’s execution context as context.inputData, which is typed according to the step’s inputSchema. \n The step can then continue execution based on the human input. \n \n This pattern allows for safe, type-checked human intervention in automated workflows. \n Interactive Terminal Example Using Inquirer \n This example demonstrates how to use the Inquirer  library to collect user input directly from the terminal when a workflow is suspended, creating a truly interactive human-in-the-loop experience. \n import { Mastra } from ' @mastra/core '; \n import { Step, Workflow } from ' @mastra/core/workflows '; \n import { z } from ' zod '; \n import { confirm, input, select } from ' @inquirer/prompts '; \n \n // Step 1: Generate product recommendations \n const generateRecommendations = new Step ({ \n id: ' generateRecommendations ', \n outputSchema: z. object ({ \n customerName: z. string (), \n recommendations: z. array ( \n z. object ({ \n productId: z. string (), \n productName: z. string (), \n price: z. number (), \n description: z. string (), \n }), \n ), \n }), \n execute: async ({ context }) =&gt; { \n const customerName = context.triggerData.customerName; \n \n // In a real application, you might call an API or ML model here \n // For this example, we'll return mock data \n return { \n customerName, \n recommendations: [ \n { \n productId: ' prod-001 ', \n productName: ' Premium Widget ', \n price: 99.99, \n description: ' Our best-selling premium widget with advanced features ', \n }, \n { \n productId: ' prod-002 ', \n productName: ' Basic Widget ', \n price: 49.99, \n description: ' Affordable entry-level widget for beginners ', \n }, \n { \n productId: ' prod-003 ', \n productName: ' Widget Pro Plus ', \n price: 149.99, \n description: ' Professional-grade widget with extended warranty ', \n }, \n ], \n }; \n }, \n}); \n // Step 2: Get human approval and customization for the recommendations \n const reviewRecommendations = new Step ({ \n id: ' reviewRecommendations ', \n inputSchema: z. object ({ \n approvedProducts: z. array (z. string ()), \n customerNote: z. string (). optional (), \n offerDiscount: z. boolean (). optional (), \n }), \n outputSchema: z. object ({ \n finalRecommendations: z. array ( \n z. object ({ \n productId: z. string (), \n productName: z. string (), \n price: z. number (), \n }), \n ), \n customerNote: z. string (). optional (), \n offerDiscount: z. boolean (), \n }), \n execute: async ({ context, suspend }) =&gt; { \n const { customerName, recommendations } = context. getStepResult (generateRecommendations) || { \n customerName: '', \n recommendations: [], \n }; \n \n // Check if we have input from a resumed workflow \n const reviewInput = { \n approvedProducts: context.inputData?.approvedProducts || [], \n customerNote: context.inputData?.customerNote, \n offerDiscount: context.inputData?.offerDiscount, \n }; \n \n // If we don't have agent input yet, suspend for human review \n if (! reviewInput.approvedProducts.length) { \n console. log ( ` Generating recommendations for customer: ${ customerName}`); \n await suspend ({ \n customerName, \n recommendations, \n message: ' Please review these product recommendations before sending to the customer ', \n }); \n \n // Placeholder return (won't be reached due to suspend) \n return { \n finalRecommendations: [], \n customerNote: '', \n offerDiscount: false, \n }; \n } \n \n // Process the agent's product selections \n const finalRecommendations = recommendations \n . filter (product =&gt; reviewInput.approvedProducts. includes (product.productId)) \n . map (product =&gt; ({ \n productId: product.productId, \n productName: product.productName, \n price: product.price, \n })); \n \n return { \n finalRecommendations, \n customerNote: reviewInput.customerNote || '', \n offerDiscount: reviewInput.offerDiscount || false, \n }; \n }, \n}); \n // Step 3: Send the recommendations to the customer \n const sendRecommendations = new Step ({ \n id: ' sendRecommendations ', \n outputSchema: z. object ({ \n emailSent: z. boolean (), \n emailContent: z. string (), \n }), \n execute: async ({ context }) =&gt; { \n const { customerName } = context. getStepResult (generateRecommendations) || { customerName: '' }; \n const { finalRecommendations, customerNote, offerDiscount } = context. getStepResult (reviewRecommendations) || { \n finalRecommendations: [], \n customerNote: '', \n offerDiscount: false, \n }; \n \n // Generate email content based on the recommendations \n let emailContent = ` Dear ${ customerName},\\n\\nBased on your preferences, we recommend:\\n\\n `; \n \n finalRecommendations. forEach (product =&gt; { \n emailContent += ` - ${ product.productName}: $ ${ product.price. toFixed ( 2)} \\n `; \n }); \n \n if (offerDiscount) { \n emailContent += ' \\nAs a valued customer, use code SAVE10 for 10% off your next purchase!\\n '; \n } \n \n if (customerNote) { \n emailContent += ` \\nPersonal note: ${ customerNote} \\n `; \n } \n \n emailContent += ' \\nThank you for your business,\\nThe Sales Team '; \n \n // In a real application, you would send this email \n console. log ( ' Email content generated: ', emailContent); \n \n return { \n emailSent: true, \n emailContent, \n }; \n }, \n}); \n \n // Build the workflow \n const recommendationWorkflow = new Workflow ({ \n name: ' product-recommendation-workflow ', \n triggerSchema: z. object ({ \n customerName: z. string (), \n }), \n}); \n \n recommendationWorkflow \n. step (generateRecommendations) \n. then (reviewRecommendations) \n. then (sendRecommendations) \n. commit (); \n \n // Register the workflow \n const mastra = new Mastra ({ \n workflows: { recommendationWorkflow }, \n}); \n // Example of using the workflow with Inquirer prompts \n async function runRecommendationWorkflow () { \n const registeredWorkflow = mastra. getWorkflow ( ' recommendationWorkflow '); \n const run = registeredWorkflow. createRun (); \n \n console. log ( ' Starting product recommendation workflow... '); \n const result = await run. start ({ \n triggerData: { \n customerName: ' Jane Smith ', \n }, \n }); \n \n const isReviewStepSuspended = result.activePaths. get ( ' reviewRecommendations ')?.status === ' suspended '; \n \n // Check if workflow is suspended for human review \n if (isReviewStepSuspended) { \n const { customerName, recommendations, message } = result.activePaths. get ( ' reviewRecommendations ')?.suspendPayload; \n \n console. log ( ' \\n=================================== '); \n console. log (message); \n console. log ( ` Customer: ${ customerName}`); \n console. log ( ' ===================================\\n '); \n \n // Use Inquirer to collect input from the sales agent in the terminal \n console. log ( ' Available product recommendations: '); \n recommendations. forEach ((product, index) =&gt; { \n console. log ( `${ index + 1}. ${ product.productName} - $ ${ product.price. toFixed ( 2)}`); \n console. log ( ` ${ product.description} \\n `); \n }); \n \n // Let the agent select which products to recommend \n const approvedProducts = await checkbox ({ \n message: ' Select products to recommend to the customer: ', \n choices: recommendations. map (product =&gt; ({ \n name: `${ product.productName} ($ ${ product.price. toFixed ( 2)}) `, \n value: product.productId, \n })), \n }); \n \n // Let the agent add a personal note \n const includeNote = await confirm ({ \n message: ' Would you like to add a personal note? ', \n default: false, \n }); \n \n let customerNote = ''; \n if (includeNote) { \n customerNote = await input ({ \n message: ' Enter your personalized note for the customer: ', \n }); \n } \n \n // Ask if a discount should be offered \n const offerDiscount = await confirm ({ \n message: ' Offer a 10% discount to this customer? ', \n default: false, \n }); \n \n console. log ( ' \\nSubmitting your review... '); \n \n // Resume the workflow with the agent's input \n const resumeResult = await run. resume ({ \n stepId: ' reviewRecommendations ', \n context: { \n approvedProducts, \n customerNote, \n offerDiscount, \n }, \n }); \n \n console. log ( ' \\n=================================== '); \n console. log ( ' Workflow completed! '); \n console. log ( ' Email content: '); \n console. log ( ' ===================================\\n '); \n console. log (resumeResult?.results?.sendRecommendations || ' No email content generated '); \n \n return resumeResult; \n } \n \n return result; \n} \n \n // Invoke the workflow with interactive terminal input \n runRecommendationWorkflow (). catch (console.error); \n Advanced Example with Multiple User Inputs \n This example demonstrates a more complex workflow that requires multiple human intervention points, such as in a content moderation system. \n import { Mastra } from ' @mastra/core '; \n import { Step, Workflow } from ' @mastra/core/workflows '; \n import { z } from ' zod '; \n import { select, input } from ' @inquirer/prompts '; \n \n // Step 1: Receive and analyze content \n const analyzeContent = new Step ({ \n id: ' analyzeContent ', \n outputSchema: z. object ({ \n content: z. string (), \n aiAnalysisScore: z. number (), \n flaggedCategories: z. array (z. string ()). optional (), \n }), \n execute: async ({ context }) =&gt; { \n const content = context.triggerData.content; \n \n // Simulate AI analysis \n const aiAnalysisScore = simulateContentAnalysis (content); \n const flaggedCategories = aiAnalysisScore &lt; 0.7 \n ? [ ' potentially inappropriate ', ' needs review '] \n : []; \n \n return { \n content, \n aiAnalysisScore, \n flaggedCategories, \n }; \n }, \n}); \n // Step 2: Moderate content that needs review \n const moderateContent = new Step ({ \n id: ' moderateContent ', \n // Define the schema for human input that will be provided when resuming \n inputSchema: z. object ({ \n moderatorDecision: z. enum ([ ' approve ', ' reject ', ' modify ']). optional (), \n moderatorNotes: z. string (). optional (), \n modifiedContent: z. string (). optional (), \n }), \n outputSchema: z. object ({ \n moderationResult: z. enum ([ ' approved ', ' rejected ', ' modified ']), \n moderatedContent: z. string (), \n notes: z. string (). optional (), \n }), \n // @ts-ignore \n execute: async ({ context, suspend }) =&gt; { \n const analysisResult = context. getStepResult (analyzeContent); \n // Access the input provided when resuming the workflow \n const moderatorInput = { \n decision: context.inputData?.moderatorDecision, \n notes: context.inputData?.moderatorNotes, \n modifiedContent: context.inputData?.modifiedContent, \n }; \n \n // If the AI analysis score is high enough, auto-approve \n if (analysisResult?.aiAnalysisScore &gt; 0.9 &amp;&amp; ! analysisResult?.flaggedCategories?.length) { \n return { \n moderationResult: ' approved ', \n moderatedContent: analysisResult.content, \n notes: ' Auto-approved by system ', \n }; \n } \n \n // If we don't have moderator input yet, suspend for human review \n if (! moderatorInput.decision) { \n await suspend ({ \n content: analysisResult?.content, \n aiScore: analysisResult?.aiAnalysisScore, \n flaggedCategories: analysisResult?.flaggedCategories, \n message: ' Please review this content and make a moderation decision ', \n }); \n \n // Placeholder return \n return { \n moderationResult: ' approved ', \n moderatedContent: '', \n }; \n } \n \n // Process the moderator's decision \n switch (moderatorInput.decision) { \n case ' approve ': \n return { \n moderationResult: ' approved ', \n moderatedContent: analysisResult?.content || '', \n notes: moderatorInput.notes || ' Approved by moderator ', \n }; \n \n case ' reject ': \n return { \n moderationResult: ' rejected ', \n moderatedContent: '', \n notes: moderatorInput.notes || ' Rejected by moderator ', \n }; \n \n case ' modify ': \n return { \n moderationResult: ' modified ', \n moderatedContent: moderatorInput.modifiedContent || analysisResult?.content || '', \n notes: moderatorInput.notes || ' Modified by moderator ', \n }; \n \n default: \n return { \n moderationResult: ' rejected ', \n moderatedContent: '', \n notes: ' Invalid moderator decision ', \n }; \n } \n }, \n}); \n // Step 3: Apply moderation actions \n const applyModeration = new Step ({ \n id: ' applyModeration ', \n outputSchema: z. object ({ \n finalStatus: z. string (), \n content: z. string (). optional (), \n auditLog: z. object ({ \n originalContent: z. string (), \n moderationResult: z. string (), \n aiScore: z. number (), \n timestamp: z. string (), \n }), \n }), \n execute: async ({ context }) =&gt; { \n const analysisResult = context. getStepResult (analyzeContent); \n const moderationResult = context. getStepResult (moderateContent); \n \n // Create audit log \n const auditLog = { \n originalContent: analysisResult?.content || '', \n moderationResult: moderationResult?.moderationResult || ' unknown ', \n aiScore: analysisResult?.aiAnalysisScore || 0, \n timestamp: new Date (). toISOString (), \n }; \n \n // Apply moderation action \n switch (moderationResult?.moderationResult) { \n case ' approved ': \n return { \n finalStatus: ' Content published ', \n content: moderationResult.moderatedContent, \n auditLog, \n }; \n \n case ' modified ': \n return { \n finalStatus: ' Content modified and published ', \n content: moderationResult.moderatedContent, \n auditLog, \n }; \n \n case ' rejected ': \n return { \n finalStatus: ' Content rejected ', \n auditLog, \n }; \n \n default: \n return { \n finalStatus: ' Error in moderation process ', \n auditLog, \n }; \n } \n }, \n}); \n // Build the workflow \n const contentModerationWorkflow = new Workflow ({ \n name: ' content-moderation-workflow ', \n triggerSchema: z. object ({ \n content: z. string (), \n }), \n}); \n \n contentModerationWorkflow \n . step (analyzeContent) \n . then (moderateContent) \n . then (applyModeration) \n . commit (); \n \n // Register the workflow \n const mastra = new Mastra ({ \n workflows: { contentModerationWorkflow }, \n}); \n \n // Example of using the workflow with Inquirer prompts \n async function runModerationDemo () { \n const registeredWorkflow = mastra. getWorkflow ( ' contentModerationWorkflow '); \n const run = registeredWorkflow. createRun (); \n \n // Start the workflow with content that needs review \n console. log ( ' Starting content moderation workflow... '); \n const result = await run. start ({ \n triggerData: { \n content: ' This is some user-generated content that requires moderation. ' \n } \n }); \n \n const isReviewStepSuspended = result.activePaths. get ( ' moderateContent ')?.status === ' suspended '; \n \n // Check if workflow is suspended \n if (isReviewStepSuspended) { \n const { content, aiScore, flaggedCategories, message } = result.activePaths. get ( ' moderateContent ')?.suspendPayload; \n \n console. log ( ' \\n=================================== '); \n console. log (message); \n console. log ( ' ===================================\\n '); \n \n console. log ( ' Content to review: '); \n console. log (content); \n console. log ( ` \\nAI Analysis Score: ${ aiScore}`); \n console. log ( ` Flagged Categories: ${ flaggedCategories?. join ( ', ') || ' None '} \\n `); \n \n // Collect moderator decision using Inquirer \n const moderatorDecision = await select ({ \n message: ' Select your moderation decision: ', \n choices: [ \n { name: ' Approve content as is ', value: ' approve ' }, \n { name: ' Reject content completely ', value: ' reject ' }, \n { name: ' Modify content before publishing ', value: ' modify ' } \n ], \n }); \n \n // Collect additional information based on decision \n let moderatorNotes = ''; \n let modifiedContent = ''; \n \n moderatorNotes = await input ({ \n message: ' Enter any notes about your decision: ', \n }); \n \n if (moderatorDecision === ' modify ') { \n modifiedContent = await input ({ \n message: ' Enter the modified content: ', \n default: content, \n }); \n } \n \n console. log ( ' \\nSubmitting your moderation decision... '); \n \n // Resume the workflow with the moderator's input \n const resumeResult = await run. resume ({ \n stepId: ' moderateContent ', \n context: { \n moderatorDecision, \n moderatorNotes, \n modifiedContent, \n }, \n }); \n \n if (resumeResult?.results?.applyModeration?.status === ' success ') { \n console. log ( ' \\n=================================== '); \n console. log ( ` Moderation complete: ${ resumeResult?.results?.applyModeration?.output.finalStatus}`); \n console. log ( ' ===================================\\n '); \n \n if (resumeResult?.results?.applyModeration?.output.content) { \n console. log ( ' Published content: '); \n console. log (resumeResult.results.applyModeration.output.content); \n } \n } \n \n return resumeResult; \n } \n \n console. log ( ' Workflow completed without requiring human intervention: ', result.results); \n return result; \n} \n \n // Helper function for AI content analysis simulation \n function simulateContentAnalysis (content: string): number { \n // In a real application, this would call an AI service \n // For the example, we're returning a random score \n return Math. random (); \n} \n \n // Invoke the demo function \n runModerationDemo (). catch (console.error); \n Key Concepts \n \n \n Suspension Points - Use the suspend() function within a step’s execute to pause workflow execution. \n \n \n Suspension Payload - Pass relevant data when suspending to provide context for human decision-making: \n \n \n await suspend ({ \n messageForHuman: ' Please review this data ', \n data: someImportantData \n }); \n \n Checking Workflow Status - After starting a workflow, check the returned status to see if it’s suspended: \n \n const result = await workflow. start ({ triggerData }); \n if (result.status === ' suspended ' &amp;&amp; result.suspendedStepId === ' stepId ') { \n // Process suspension \n console. log ( ' Workflow is waiting for input: ', result.suspendPayload); \n } \n \n Interactive Terminal Input - Use libraries like Inquirer to create interactive prompts: \n \n import { select, input, confirm } from ' @inquirer/prompts '; \n \n // When the workflow is suspended \n if (result.status === ' suspended ') { \n // Display information from the suspend payload \n console. log (result.suspendPayload.message); \n \n // Collect user input interactively \n const decision = await select ({ \n message: ' What would you like to do? ', \n choices: [ \n { name: ' Approve ', value: ' approve ' }, \n { name: ' Reject ', value: ' reject ' } \n ] \n }); \n \n // Resume the workflow with the collected input \n await run. resume ({ \n stepId: result.suspendedStepId, \n context: { decision } \n }); \n } \n \n Resuming Workflow - Use the resume() method to continue workflow execution with human input: \n \n const resumeResult = await run. resume ({ \n stepId: ' suspendedStepId ', \n context: { \n // This data is passed to the suspended step as context.inputData \n // and must conform to the step's inputSchema \n userDecision: ' approve ' \n }, \n }); \n \n Input Schema for Human Data - Define an input schema on steps that might be resumed with human input to ensure type safety: \n \n const myStep = new Step ({ \n id: ' myStep ', \n inputSchema: z. object ({ \n // This schema validates the data passed in resume's context \n // and makes it available as context.inputData \n userDecision: z. enum ([ ' approve ', ' reject ']), \n userComments: z. string (). optional (), \n }), \n execute: async ({ context, suspend }) =&gt; { \n // Check if we have user input from a previous suspension \n if (context.inputData?.userDecision) { \n // Process the user's decision \n return { result: ` User decided: ${ context.inputData.userDecision}` }; \n } \n \n // If no input, suspend for human decision \n await suspend (); \n } \n }); \n Human-in-the-loop workflows are powerful for building systems that blend automation with human judgment, such as: \n \n Content moderation systems \n Approval workflows \n Supervised AI systems \n Customer service automation with escalation \n \n \n",
    "image": "https://mastra.ai/api/og/docs?title=Example:%20Human%20in%20the%20Loop%20|%20Workflows%20|%20Mastra%20Docs&description=Example%20of%20using%20Mastra%20to%20create%20workflows%20with%20human%20intervention%20points.",
    "favicon": "https://mastra.ai/favicon.ico",
    "extras": {
        "links": [
            "https://mastra.ai/en/examples/workflows/human-in-the-loop",
            "https://mastra.ai/",
            "https://mastra.ai/docs",
            "https://mastra.ai/examples"
        ]
    }
}