{
    "id": "https://mastra.ai/docs/workflows/runtime-variables",
    "title": "Runtime variables - dependency injection | Workflows | Mastra Docs",
    "url": "https://mastra.ai/docs/workflows/runtime-variables",
    "author": "",
    "text": "Workflow Runtime Variables \n Mastra provides a powerful dependency injection system that enables you to configure your workflows and steps with runtime variables. This feature is essential for creating flexible and reusable workflows that can adapt their behavior based on runtime configuration. \n Overview \n The dependency injection system allows you to: \n \n Pass runtime configuration variables to workflows through a type-safe runtimeContext \n Access these variables within step execution contexts \n Modify workflow behavior without changing the underlying code \n Share configuration across multiple steps within the same workflow \n \n Basic Usage \n const myWorkflow = mastra. getWorkflow ( \" myWorkflow \"); \n const { runId, start, resume } = myWorkflow. createRun (); \n \n // Define your runtimeContext's type structure \n type WorkflowRuntimeContext = { \n multiplier: number; \n}; \n \n const runtimeContext = new RuntimeContext &lt; WorkflowRuntimeContext &gt;(); \n runtimeContext. set ( \" multiplier \", 5); \n \n // Start the workflow execution with runtimeContext \n await start ({ \n triggerData: { inputValue: 45 }, \n runtimeContext, \n}); \n Using with REST API \n Here’s how to dynamically set a multiplier value from an HTTP header: \n import { Mastra } from \" @mastra/core \"; \n import { RuntimeContext } from \" @mastra/core/di \"; \n import { workflow as myWorkflow } from \"./workflows \"; \n \n // Define runtimeContext type with clear, descriptive types \n type WorkflowRuntimeContext = { \n multiplier: number; \n}; \n \n export const mastra = new Mastra ({ \n workflows: { \n myWorkflow, \n }, \n server: { \n middleware: [ \n async (c, next) =&gt; { \n const multiplier = c.req. header ( \" x-multiplier \"); \n const runtimeContext = c. get &lt; WorkflowRuntimeContext &gt;( \" runtimeContext \"); \n \n // Parse and validate the multiplier value \n const multiplierValue = parseInt (multiplier || \" 1 \", 10); \n if ( isNaN (multiplierValue)) { \n throw new Error ( \" Invalid multiplier value \"); \n } \n \n runtimeContext. set ( \" multiplier \", multiplierValue); \n \n await next (); // Don't forget to call next() \n }, \n ], \n }, \n}); \n Creating Steps with Variables \n Steps can access runtimeContext variables and must conform to the workflow’s runtimeContext type: \n import { Step } from \" @mastra/core/workflow \"; \n import { z } from \" zod \"; \n \n // Define step input/output types \n interface StepInput { \n inputValue: number; \n} \n \n interface StepOutput { \n incrementedValue: number; \n} \n \n const stepOne = new Step ({ \n id: \" stepOne \", \n description: \" Multiply the input value by the configured multiplier \", \n execute: async ({ context, runtimeContext }) =&gt; { \n try { \n // Type-safe access to runtimeContext variables \n const multiplier = runtimeContext. get ( \" multiplier \"); \n if (multiplier === undefined) { \n throw new Error ( \" Multiplier not configured in runtimeContext \"); \n } \n \n // Get and validate input \n const inputValue = \n context. getStepResult &lt; StepInput &gt;( \" trigger \")?.inputValue; \n if (inputValue === undefined) { \n throw new Error ( \" Input value not provided \"); \n } \n \n const result: StepOutput = { \n incrementedValue: inputValue * multiplier, \n }; \n \n return result; \n } catch (error) { \n console. error ( ` Error in stepOne: ${ error.message}`); \n throw error; \n } \n }, \n}); \n Error Handling \n When working with runtime variables in workflows, it’s important to handle potential errors: \n \n Missing Variables: Always check if required variables exist in the runtimeContext \n Type Mismatches: Use TypeScript’s type system to catch type errors at compile time \n Invalid Values: Validate variable values before using them in your steps \n \n // Example of defensive programming with runtimeContext variables \n const multiplier = runtimeContext. get ( \" multiplier \"); \n if (multiplier === undefined) { \n throw new Error ( \" Multiplier not configured in runtimeContext \"); \n} \n \n // Type and value validation \n if ( typeof multiplier !== \" number \" || multiplier &lt;= 0) { \n throw new Error ( ` Invalid multiplier value: ${ multiplier}`); \n} \n Best Practices \n \n Type Safety: Always define proper types for your runtimeContext and step inputs/outputs \n Validation: Validate all inputs and runtimeContext variables before using them \n Error Handling: Implement proper error handling in your steps \n Documentation: Document the expected runtimeContext variables for each workflow \n Default Values: Provide sensible defaults when possible \n Nested Workflows new Overview new",
    "image": "https://mastra.ai/api/og/docs?title=Runtime%20variables%20-%20dependency%20injection%20|%20Workflows%20|%20Mastra%20Docs&description=Learn%20how%20to%20use%20Mastra%27s%20dependency%20injection%20system%20to%20provide%20runtime%20configuration%20to%20workflows%20and%20steps.",
    "favicon": "https://mastra.ai/favicon.ico",
    "extras": {
        "links": [
            "https://mastra.ai/en/docs/workflows/runtime-variables",
            "https://mastra.ai/",
            "https://mastra.ai/docs",
            "https://mastra.ai/examples"
        ]
    }
}